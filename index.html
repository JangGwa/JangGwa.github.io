<!DOCTYPE html>
<html lang="zh-CN">
  <head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">

<meta name="theme-color" content="#f8f5ec">
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="google-site-verification" content="UA-136124913-1"><link rel="alternate" href="/default" title="jinguo's home"><link rel="shortcut icon" type="image/x-icon" href="/gou.jpg?v=2.11.0">
<link rel="canonical" href="http://yoursite.com/">

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css"><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css">
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-136124913-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-136124913-1');
</script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "IjDFyQ3yasLyrQTbfVxBRd9n-gzGzoHsz",
      appKey: "XzgCCdnbtrGLTQmVxBRrxYhe"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"IjDFyQ3yasLyrQTbfVxBRd9n-gzGzoHsz","app_key":"XzgCCdnbtrGLTQmVxBRrxYhe"},"toc":true,"fancybox":true,"pjax":true,"latex":false};
</script>

    <title>jinguo's home</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">jinguo's home</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/categories">
        <li class="mobile-menu-item">分类
          </li>
      </a><a href="/about">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">jinguo's home</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            分类
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/14/书评-YDKJS类型与文法/">书评-YDKJS类型与文法</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-14
        </span><span class="post-category">
            <a href="/categories/前端/">前端</a>
            </span>
        <span class="post-visits" data-url="/2019/03/14/书评-YDKJS类型与文法/" data-title="书评-YDKJS类型与文法">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h2 id="第一章：类型"><a href="#第一章：类型" class="headerlink" title="第一章：类型"></a>第一章：类型</h2><p>JavaScript 定义了七种内建类型：null、undefined、boolean、number、string、object、symbol。</p>
<p>typeof 操作符可以检测给定值的类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;   <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">42</span>            === <span class="string">"number"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">"42"</span>          === <span class="string">"string"</span>;    <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">42</span> &#125;  === <span class="string">"object"</span>;    <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 ES6 中被加入的！</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()      === <span class="string">"symbol"</span>;    <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>typeof 操作符是有 bug 的， 那就是 typeof null === “object”; // true 这个 bug 已经存在了近二十年，而且好像永远也不会被修复了，以为修复它可能会引起更多的 bug。</p>
<p>如果你想用 null 类型来测试 null 值，需要一个符合条件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>特别需要注意的是 typeof function(){} 是 “function”。</p>
<p>typeof 操作符总是返回字符串。</p>
<h2 id="第二章：值"><a href="#第二章：值" class="headerlink" title="第二章：值"></a>第二章：值</h2><p>Array 有两个点需要注意：</p>
<ol>
<li>如果用 delete 删除 Array 上的元素，他只是移除这个值槽，不会更新 length 属性。</li>
<li>如果一个可以被强制转换为10进制 number 的 string 值被用作键的话，它会认为你想使用 number 索引而不是一个 string 键！</li>
</ol>
<p>类数组转换成数组一般使用以下两种方式：</p>
<ol>
<li>Array.prototype.slice.call(arguments)</li>
<li>Array.from(arguments);</li>
</ol>
<p>JavaScript 的 number 的实现基于”IEEE 754”标准，通常被称为浮点。Javascript 明确使用了这个标准的“双精度”</p>
<p>针对 0.1 + 0.2 === 0.3 // false 这个问题的解释简单说是因为 0.1 和 0.2 的二进制表现形式是不精准的，所以他们相加时，结果不是精确的0.3.</p>
<p>测试是否是整数可以使用 Number.isInteger(),模拟实现如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger) &#123;</span><br><span class="line">	<span class="built_in">Number</span>.isInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">typeof</span> num == <span class="string">"number"</span> &amp;&amp; num % <span class="number">1</span> == <span class="number">0</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试是否是安全整数可以使用 Number.isSafeInteger(),模拟实现如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger) &#123;</span><br><span class="line">	<span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Number</span>.isInteger( num ) &amp;&amp;</span><br><span class="line">			<span class="built_in">Math</span>.abs( num ) &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>表达式 void __ 会“躲开”任何值，所以这个表达式的结果总是值 undefined。它不会修改任何已经存在的值；只是确保不会有值从操作符表达式中返回来。</p>
<p>在 ES6 中，有一个新工具可以用于测试两个值的绝对等价性，而没有任何这些例外。它称为 Object.is(..):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span> / <span class="string">"foo"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">-3</span> * <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( a, <span class="literal">NaN</span> );	<span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">-0</span> );		<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is( b, <span class="number">0</span> );		<span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>Object.is()的模拟实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Object</span>.is) &#123;</span><br><span class="line">	<span class="built_in">Object</span>.is = <span class="function"><span class="keyword">function</span>(<span class="params">v1, v2</span>) </span>&#123;</span><br><span class="line">		<span class="comment">// 测试 `-0`</span></span><br><span class="line">		<span class="keyword">if</span> (v1 === <span class="number">0</span> &amp;&amp; v2 === <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span> / v1 === <span class="number">1</span> / v2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 测试 `NaN`</span></span><br><span class="line">		<span class="keyword">if</span> (v1 !== v1) &#123;</span><br><span class="line">			<span class="keyword">return</span> v2 !== v2;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 其他情况</span></span><br><span class="line">		<span class="keyword">return</span> v1 === v2;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="第三章：原生类型"><a href="#第三章：原生类型" class="headerlink" title="第三章：原生类型"></a>第三章：原生类型</h2><p>原生类型实际上就是内建函数，有以下几种 String()、Number()、Boolean()、Array()、Object()、Function()、RegExp()、Date()、Error()、Symbol()</p>
<h2 id="第四章：强制转换"><a href="#第四章：强制转换" class="headerlink" title="第四章：强制转换"></a>第四章：强制转换</h2><p>在观察代码时如果一个类型转换明显是有意为之的，那么它就是“明确强制转换”，而如果这个类型转换是做为其他操作的不那么明显的副作用发生的，那么它就是“隐含强制转换”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = a + <span class="string">""</span>;			<span class="comment">// 隐含强制转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">String</span>( a );	<span class="comment">// 明确强制转换</span></span><br></pre></td></tr></table></figure></p>
<p>JSON.stringify(..) 工具在遇到 undefined、function、和 symbol 时将会自动地忽略它们。如果在一个 array 中遇到这样的值，它会被替换为 null（这样数组的位置信息就不会改变）。如果在一个 object 的属性中遇到这样的值，这个属性会被简单地剔除掉。</p>
<p>但如果你试着 JSON.stringify(..) 一个带有循环引用的 object，就会抛出一个错误。</p>
<p>如果你打算 JSON 字符串化一个可能含有非法 JSON 值的对象，或者如果这个对象中正好有不适于序列化的值，那么你就应当为它定义一个 toJSON() 方法，返回这个 object 的一个 JSON 安全 版本。</p>
<p>宽松等价是==操作符，而严格等价是===操作符。</p>
<p>关于这两个操作符的一个非常常见的误解是：“==检查值的等价性，而===检查值和类型的等价性。”</p>
<p>正确的描述是：“==允许在等价性比较中进行强制转换，而===不允许强制转换”。</p>
<p>比较 null 和 undefiined，宽松等价两个相等</p>
<p>比较 number 和 string，把 string 转换成 number</p>
<p>比较 boolean 和其他，把 boolean 转换成 number</p>
<p>比较 object 和非 object，把 object 调用 ToPrimitive() 方法</p>
<h2 id="第五章：文法"><a href="#第五章：文法" class="headerlink" title="第五章：文法"></a>第五章：文法</h2><p>JavaScript文法有相当多的微妙之处，我们作为开发者应当比平常多花一点儿时间来关注它。一点儿努力可以帮助你巩固对这个语言更深层次的知识。</p>
<p>语句和表达式在英语中有类似的概念 —— 语句就像句子，而表达式就像短语。表达式可以是纯粹的/自包含的，或者他们可以有副作用。</p>
<p>JavaScript文法层面的语义用法规则（也就是上下文），是在纯粹的语法之上的。例如，用于你程序中不同地方的{ }可以意味着块儿，object 字面量，（ES6）解构语句，或者（ES6）被命名的函数参数。</p>
<p>JavaScript有几种类型的错误，但很少有人知道它有两种类别的错误：“早期”（编译器抛出的不可捕获的）和“运行时”（可以try..catch的）。所有在程序运行之前就使它停止的语法错误都明显是早期错误，但也有一些别的错误。</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/03/13/书评-YDKJSthis与对象原型/">书评-YDKJSthis与对象原型</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-03-13
        </span><span class="post-category">
            <a href="/categories/前端/">前端</a>
            </span>
        <span class="post-visits" data-url="/2019/03/13/书评-YDKJSthis与对象原型/" data-title="书评-YDKJSthis与对象原型">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h2 id="第一章：this-是什么"><a href="#第一章：this-是什么" class="headerlink" title="第一章：this 是什么"></a>第一章：this 是什么</h2><p>this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。 this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。</p>
<p>this 既不是函数自身的引用，也不是函数词法作用域的引用。</p>
<p>this 实际上是在函数被调用时建立的一个绑定，它指向什么是完全由函数被调用的调用点来决定的。<br>
          <div class="read-more">
            <a href="/2019/03/13/书评-YDKJSthis与对象原型/" class="read-more-link">阅读更多</a>
          </div>
        </p></div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/02/18/书评-YDKJS作用域和闭包/">书评-YDKJS作用域与闭包</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-18
        </span><span class="post-category">
            <a href="/categories/前端/">前端</a>
            </span>
        <span class="post-visits" data-url="/2019/02/18/书评-YDKJS作用域和闭包/" data-title="书评-YDKJS作用域与闭包">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h2 id="第一章-什么是作用域？"><a href="#第一章-什么是作用域？" class="headerlink" title="第一章 什么是作用域？"></a>第一章 什么是作用域？</h2><p>几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力。<br>作用域就是定义如何在某些位置存储变量，以及如何在稍后找到这些变量。</p>
<h3 id="编译器理论"><a href="#编译器理论" class="headerlink" title="编译器理论"></a>编译器理论</h3><p>编译的三个步骤</p>
<p>1.分词/词法分析：将一连串的字符打断成有意义的片段，称为 token，例子：<code>var a = 2;=&gt; var, a, =, 2, ;</code>。</p>
<p>2.解析：将一个 token 的流转换成一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为抽象语法树（AST）</p>
<p>3.代码生成：这个处理将抽象语法树转换为可执行的代码。</p>
<p>JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中。对于 JavaScript 来说，在许多情况下，编译发生在代码执行前的仅仅几微秒之内。为了确保最快的性能，JS 引擎使用了 JIT等等<br>
          <div class="read-more">
            <a href="/2019/02/18/书评-YDKJS作用域和闭包/" class="read-more-link">阅读更多</a>
          </div>
        </p></div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/02/15/书评-YDKJS入门与进阶/">书评-YDKJS入门与进阶</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-15
        </span><span class="post-category">
            <a href="/categories/前端/">前端</a>
            </span>
        <span class="post-visits" data-url="/2019/02/15/书评-YDKJS入门与进阶/" data-title="书评-YDKJS入门与进阶">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h2 id="第一章：进入编程"><a href="#第一章：进入编程" class="headerlink" title="第一章：进入编程"></a>第一章：进入编程</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>代码是一组告诉计算机要执行什么任务的特殊指令。通常保存在文本文件中，也可以在浏览器的开发者控制台中直接键入代码。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>一组单词，数字，和执行一种具体任务的操作符构成了一个语句。语句包含了变量、字面量、操作符。例如<code>a = b * 2;</code> 就是一个语句，而 a、b 是变量，2是字面量，=、* 是操作符。</p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>一个表达式是一个引用，指向变量或值，或者一组用操作符组合的变量和值。<br>
          <div class="read-more">
            <a href="/2019/02/15/书评-YDKJS入门与进阶/" class="read-more-link">阅读更多</a>
          </div>
        </p></div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2019/02/13/学习-TypeScript入门/">学习-TypeScript入门</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-02-13
        </span><span class="post-category">
            <a href="/categories/前端/">前端</a>
            </span>
        <span class="post-visits" data-url="/2019/02/13/学习-TypeScript入门/" data-title="学习-TypeScript入门">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h2 id="什么是-TypeScript"><a href="#什么是-TypeScript" class="headerlink" title="什么是 TypeScript"></a>什么是 TypeScript</h2><p>TypeScript 是 JavaScript 的超集，主要提供了类型系统和对 ES6 的支持。它编译出来是 JavaScript，可以运行在任何浏览器上。</p>
<h3 id="TypeScript-的优点"><a href="#TypeScript-的优点" class="headerlink" title="TypeScript 的优点"></a>TypeScript 的优点</h3><ol>
<li>增加了代码的可读性和可维护性（类型系统、编译报错、代码补全、接口提示等）</li>
<li>TypeScript 非常包容（类型推论、定义一切类型、兼容三方库等）</li>
<li>TypeScript 拥有活跃的社区（Angular2 是 TypeScript 编写，大部分三方库提供 TypeScript 类型定义文件）<h3 id="TypeScript-的缺点"><a href="#TypeScript-的缺点" class="headerlink" title="TypeScript 的缺点"></a>TypeScript 的缺点</h3></li>
<li>有一定的学习成本（接口、泛型等）</li>
<li>会增加一些开发成本（多写一些类型的定义）
          <div class="read-more">
            <a href="/2019/02/13/学习-TypeScript入门/" class="read-more-link">阅读更多</a>
          </div>
        </li></ol></div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/08/13/学习-View的事件分发机制/">学习-View的事件分发机制</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-13
        </span><span class="post-category">
            <a href="/categories/Android/">Android</a>
            </span>
        <span class="post-visits" data-url="/2016/08/13/学习-View的事件分发机制/" data-title="学习-View的事件分发机制">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><p>##1.View点击事件的传递规则<br>首先,用户触摸屏幕的时候系统必须对事件做出相应反应.而这个事件就是产生一个MotionEvent然后按照一定的规则传递给每一个View去进行相应的处理.这就是我们所谓的事件分发了.点击事件的分发主要设计一下几个主要的方法:</p>
<p>用来进行事件的分发.如果有事件传递给当前的View,那么该View一定会去调用这个方法</p>
<p>返回值受当前View的onTouchEvent和下级View的dispatchTouchEvent的影响</p>
<p>返回值表示当前的事件时候已经被处理完成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个方法在上面那个方法中内部调用,用来判断是否拦截这个事件</p>
<p>如果当前View拦截了某个事件 那么在同一个事件序列中就不会再次被调用</p>
<p>返回值表示是否拦截当前事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent e)</span></span></span><br></pre></td></tr></table></figure></p>
<p>也是在第一个方法中去调用 用来处理拦截下来的事件</p>
<p>返回值为真表示该事件已经被处理 否则 没有处理 </p>
<p>在同一事件序列中View无法再次接收到事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent e)</span></span></span><br></pre></td></tr></table></figure></p>
<p>可以用一段伪代码来表示一下三者的关系:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span></span><br><span class="line"><span class="function">  <span class="keyword">boolean</span> consume </span>= <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (onInterceptTouchEvent(e)) </span><br><span class="line">    consume = onTouchEvent(e)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    consume = childView.dispathcTouchEvent(e)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码中我们基本可以总结出这样的结论:<br><strong><em>对于一个根ViewGroup来说,当接收到一个MotionEvent的时候:</em></strong><br>调用dispatchTouchEvent方法调用onInterceptTouchEvent方法返回值为true,则表示拦截当前事件,调用onTouchEvent来处理这个事件<br>返回值为false,则当前事件将会被传递给childView,childView继续调用dispatchTouchEvent方法。如此往复,直至事件被处理.<br><strong><em>当一个View需要处理一个事件的时候</em></strong><br>如果该View设置了onTouchListener,则会调用onTouch方法如果onTouch方法返回false,则去调用onTouchEvent如果设置了onClickListener,那么在onTouchEvent方法中将会调用onClick方法。反之,onTouchEvent则不会被调用</p>
<p>当一个事件产生的时候,它的传递过程遵循这样的过程:Activity-&gt;Windows-&gt;View;事件总是先传递给Activity,Activity在传递给Windows,Windows在传递给View;如果View将事件处理了,则该事件相应就结束了.否则,事件将一级一级的继续返回,最终会传递给Activity的onTouchEvent处理.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  Toast.makeText(MainActivity.<span class="keyword">this</span>, event.getAction() + <span class="string">"我是Activity"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当你没有给任何控件设置相应事件的时候(也就是都会返回false),那么你就会看到Activity的onTouchEvent被调用了.<br>在开发艺术这本书中提到了几个结论:<br>1.同一个事件序列是指手指接触屏幕那一刻起,到手指离开屏幕那一刻结束,在这个过程中所有产生的事件都属于这一个事件序列.包括一个ACTION_DOWN,一个ACTION_UP和n个ACTION_MOVE;</p>
<p>2.某一个View一旦决定拦截事件,那么这一事件序列都只能由它来处理.</p>
<p>这个结论认真想了一下,似乎有点问题;假如这个View我设置了onTouchListener,但是我依然返回false,这个事件序列仍然会传递给父View,当然了,这个View也只能接收到一个ACTION_DOWN事件,ACTION_UP和ACTION_MOVE不会接收到.假如这个View同时还设置了onClickListener,onTouchEvent返回false的时候事件会交给onTouchEvent处理这个事件,不会在交给父View处理了.这个问题还是需要结合源码来看一下;<br>3.某个View一旦开始处理一个事件,如果它不消耗ACTION_DOWN事件,那么同一时间序列也不会交给他来处理了.</p>
<p>4.如果View不消耗ACTION_DWON以外的事件,那么这个点击事件就会消失,不会在交还给父View处理.最后会交回activity处理.</p>
<p>5.ViewGroup默认不拦截任何事件,他的onInterceptTouch方法默认返回false;View没有onInterceptTouch方法,收到事件他的onTouchEvent事件就会被调用.</p>
<p>6.View的onTouchEvent默认都会消耗事件(返回true),除非他是不可点击的(clickable和龙Clickable同时为false).View的longClickable默认都是false,clickable分情况.</p>
<p>##2.Activity对事件的分发<br>点击事件用MotionEvent来表示,当点击事件发生的时候,事件最先传递给当前Activity,由Activity的dispatchTouchEvent来进行事件派发,具体工作是由Activity内部的Windows来处理的.Windows会将事件传递给decor view,即当前View的root view.先看一下Activity的dispatchTouchEvent源码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">diapatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">    onUserInteraction();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (getWindows.superDispatchTouchEvent()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> onTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个onUserInteraction<br>方法,点进去发现这个方法是一个空方法,文档是这样写的:</p>
<blockquote>
<p>Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and onUserLeaveHint() are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. All calls to your activity’s onUserLeaveHint() callback will be accompanied by calls to onUserInteraction(). This ensures that your activity will be told of relevant user activity such as pulling down the notification pane and touching an item there. Note that this callback will be invoked for the touch down action that begins a touch gesture, but may not be invoked for the touch-moved and touch-up actions that follow.</p>
</blockquote>
<p>大体意思就是说onUserInteraction是帮助我们知道用户开始和屏幕进行交互的回调函数.另外,还会和onUserLeaveHint<br>一起更加智能的管理状态栏通知.</p>
<blockquote>
<p>Called as part of the activity lifecycle when an activity is about to go into the background as the result of user choice. For example, when the user presses the Home key, onUserLeaveHint() will be called, but when an incoming phone call causes the in-call Activity to be automatically brought to the foreground, onUserLeaveHint() will not be called on the activity being interrupted. In cases when it is invoked, this method is called right before the activity’s onPause() callback. This callback and onUserInteraction() are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication.</p>
</blockquote>
<p>这里这两个方法对我们不是很重要了,根据分析可以知道,activity通过windows来分发事件,当所有的view都没有接收处理事件的时候,activity就会自己调用自己的onTouchEvent()来处理这个事件了.<br>继续看getWindows.superDispatchTouchEvent()<br>,window<br>是个抽象类,</p>
<blockquote>
<p>Abstract base class for a top-level window look and behavior policy. An instance of this class should be used as the top-level view added to the window manager. It provides standard UI policies such as a background, title area, default key processing, etc. The only existing implementation of this abstract class is android.view.PhoneWindow, which you should instantiate when needing a Window.</p>
</blockquote>
<p>根据文档的描述,我们可以知道window<br>的唯一实现类是android.view.PhoneWindow<br>,那么他的dispatchTouchEvent<br>是怎么实现的呢?<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PhoneWindow#superDispatchTouchEvent</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent e)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mDecor.superDispatchTouchEvent(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的思路很清晰了,直接分发给mDecor处理,那么DecorView是什么东西呢?<a href="http://blog.csdn.net/windskier/article/details/6957854" target="_blank" rel="noopener">关于activity的层次点击这里</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//this is the top-level view of the window,containing the window decor(装饰)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DecorView</span> <span class="keyword">extends</span> <span class="title">FrameLayout</span> <span class="keyword">implements</span> <span class="title">RootViewSurfaceTaker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> DecorView mDecor;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">getDecorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mDecor) &#123;</span><br><span class="line">      installDecor();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> mDecor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到了这事件会继续分发,到我们通过setContentView设置的ViewGroup那里继续处理.</p>
<p>##3.ViewGroup对事件的分发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check for interception.</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">    intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">    ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    intercepted = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">  <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line">  intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码是来判断是否要来拦截当前的点击事件的.可以看出当这个事件是一个事件序列的开端,也就是一个ACTION_DOWN,就用去调用onInterceptTouch方法去判断是否要去拦截这个事件;或者当mFirstTouchTarget不为空的时候,也会去判断.相反,就不会拦截了.这也说明了一个事件如果View不去处理他的ACTION_DWON事件为什么就能在去处理其他的事件了.<br>当ViewGroup不处理事件要继续分发的时候代码是这样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find a child that can receive the event.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Scan children from front to back.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line">&amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> <span class="keyword">int</span> childIndex = customOrder</span><br><span class="line"></span><br><span class="line"> ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">final</span> View child = (preorderedList == <span class="keyword">null</span>)</span><br><span class="line"></span><br><span class="line"> ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// If there is a view that has accessibility focus we want it</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// to get the event first and if not handled we will perform a</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// normal dispatch. We may do a double iteration but this is</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// safer given the timeframe.</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"> i = childrenCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line"></span><br><span class="line"> || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line"></span><br><span class="line"> ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newTouchTarget = getTouchTarget(child);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line"></span><br><span class="line"> newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resetCancelNextUpFlag(child);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line"></span><br><span class="line"> mLastTouchDownTime = ev.getDownTime();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line"></span><br><span class="line"> mLastTouchDownIndex = j;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> mLastTouchDownIndex = childIndex;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> mLastTouchDownX = ev.getX();</span><br><span class="line"></span><br><span class="line"> mLastTouchDownY = ev.getY();</span><br><span class="line"></span><br><span class="line"> newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line"></span><br><span class="line"> alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line"></span><br><span class="line">ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑也比清晰,遍历ViewGroup的所有子View,找出能接受事件的所有元素;要满足两个条件:1.坐标是否落在子View中2.是否正在播放动画.满足这两个条件,就会分发给他来处理,要是返回了true就表示事件已经被处理,mFirstTouchTarget就会被赋值并终止此次分发,否则继续分发过程.</p>
<p>##4.View对点击事件的处理过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//View#dispatchTouchEvent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//noinspection SimplifiableIfStatement</span></span><br><span class="line"></span><br><span class="line"> ListenerInfo li = mListenerInfo;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnTouchListener != <span class="keyword">null</span></span><br><span class="line"></span><br><span class="line"> &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line"></span><br><span class="line"> &amp;&amp; li.mOnTouchListener.onTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line"></span><br><span class="line"> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line"></span><br><span class="line"> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里相对比较简单,首先判断是否设置了onTouchListener,如果设置了就去调用onTouch方法,如果返回了false,则去调用onTouchEvent方法; <strong><em>在view设置了onClickListener或者onLongClickListener后,会自动将CLICKABLE或者LONG_CLICKABLE变成ture;</em></strong></p>
<p>##最后三张图十分清晰</p>
<p>效果图如下：<br>View不处理事件流程图（View没有消费事件）<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_ignorant.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_ignorant.png?raw=true" alt="Touch Ignore"></a><br>View处理事件<a href="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_interested.png?raw=true" target="_blank" rel="noopener"><img src="https://github.com/hanhailong/AndroidStudyResources/blob/master/screenshot/view_touch_interested.png?raw=true" alt="Touch interest"></a><br>事件拦截<a href="https://raw.githubusercontent.com/hanhailong/AndroidStudyResources/master/screenshot/view_touch_intercept.png" target="_blank" rel="noopener"><img src="https://raw.githubusercontent.com/hanhailong/AndroidStudyResources/master/screenshot/view_touch_intercept.png" alt="Touch Intercept"></a></p>
<p>##附录<br>以后每个知识点的实践学习代码会上传到我的<a href="https://github.com/JangGwa" target="_blank" rel="noopener">GitHub</a>,欢迎大家一起学习-.-~</p>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2016/08/03/学习-EventBus源码分析/">学习-EventBus源码分析</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-08-03
        </span><span class="post-category">
            <a href="/categories/Android/">Android</a>
            </span>
        <span class="post-visits" data-url="/2016/08/03/学习-EventBus源码分析/" data-title="学习-EventBus源码分析">
          阅读次数 0
        </span>
        </div>
    </header>

    <div class="post-content"><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">EventBus</a>是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息。优点是开销小，代码更优雅，以及将发送者和接收者解耦。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>1.新建一个类，AnyEventType。可以是网络请求返回的字符串，也可以是某个开关状态，也可以是空。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyEventType</span> </span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnyEventType</span><span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.注册订阅者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().register(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<p>3.发送事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(<span class="keyword">new</span> AnyEventType event);</span><br></pre></td></tr></table></figure></p>
<p>4.编写响应事件订阅方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Subscribe</span>(threadMode = ThreadMode.BACKGROUND, sticky = <span class="keyword">true</span>, priority = <span class="number">100</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里说明一下3.0之后可以通过@Subscribe注解,来确定运行的线程threadMode,是否接受粘性事件sticky以及事件优先级priority,而且方法名不在需要onEvent开头,所以又简洁灵活了不少.</p>
<p>5.解除注册<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().unregister(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h5 id="1-新建EventBus"><a href="#1-新建EventBus" class="headerlink" title="1.新建EventBus"></a>1.新建EventBus</h5><ul>
<li><p>默认可通过静态函数 getDefault 获取单例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">  <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">  &#125;&#125;&#125;</span><br><span class="line"><span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EventBusBuilder 新建一个 EventBus</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBusBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数新建一个EventBus</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2-register"><a href="#2-register" class="headerlink" title="2.register"></a>2.register</h5><p>register 函数中会先根据订阅者类名去subscriberMethodFinder<br>中查找当前订阅者所有事件响应函数，然后循环每一个事件响应函数，依次执行subscribe 函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123; </span><br><span class="line">subscriberClass = subscriber.getClass();</span><br><span class="line">List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); </span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; </span><br><span class="line">  <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123; </span><br><span class="line">    subscribe(subscriber, subscriberMethod); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1798479-dd8d29a5d1134618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="register.png"></p>
<h5 id="3-subscribe"><a href="#3-subscribe" class="headerlink" title="3.subscribe"></a>3.subscribe</h5><p>源码太长就不全部贴出来了</p>
<p>1.首先通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；如果添加过就抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line"><span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">    subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">    subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span>+ eventType);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); </span><br><span class="line"><span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123; </span><br><span class="line">  subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();         </span><br><span class="line">  typesBySubscriber.put(subscriber, subscribedEvents); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3.检查这个事件是否是 Sticky 事件，如果是则立即分发sticky事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (subscriberMethod.sticky) &#123; </span><br><span class="line"><span class="comment">//eventInheritance 表示是否分发订阅了响应事件类父类事件的方法 </span></span><br><span class="line">  <span class="keyword">if</span> (eventInheritance) &#123; </span><br><span class="line">    Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; </span><br><span class="line">      Class&lt;?&gt; candidateEventType = entry.getKey(); </span><br><span class="line">      <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123; </span><br><span class="line">        Object stickyEvent = entry.getValue(); </span><br><span class="line">        checkPostStickyEventToSubscription(newSubscription, stickyEvent); </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    Object stickyEvent = stickyEvents.get(eventType); </span><br><span class="line">    checkPostStickyEventToSubscription(newSubscription, stickyEvent); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="4-post"><a href="#4-post" class="headerlink" title="4.post"></a>4.post</h5><p>首先得到当前线程的 post 信息PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用postSingleEvent 函数发布队列中的每个事件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123; </span><br><span class="line">PostingThreadState postingState = currentPostingThreadState.get(); </span><br><span class="line">List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); </span><br><span class="line"><span class="keyword">if</span> (!postingState.isPosting) &#123; </span><br><span class="line">  postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); </span><br><span class="line">  postingState.isPosting = <span class="keyword">true</span>; </span><br><span class="line">  <span class="keyword">if</span> (postingState.canceled) &#123; </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>); </span><br><span class="line">  &#125; <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123; </span><br><span class="line">    postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">    postingState.isPosting = <span class="keyword">false</span>; </span><br><span class="line">    postingState.isMainThread = <span class="keyword">false</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。ThreadMode 共有四类：</p>
<ul>
<li>PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：<strong>对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作</strong>；</li>
<li>MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：<strong>必须在主线程执行的操作</strong>；</li>
<li>BackgroundThread：在后台线程中执行响应方法。如果发布线程<strong>不是</strong>主线程，则直接调用订阅者的事件响应函数，否则启动<strong>唯一的</strong>后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：<em>操作轻微耗时且不会过于频繁</em>，即一般的耗时操作都可以放在这里；</li>
<li>Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：<em>长耗时操作，例如网络访问</em>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1798479-5b504eff0adda787.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post.png"></p>
<h5 id="5-unregister"><a href="#5-unregister" class="headerlink" title="5.unregister"></a>5.unregister</h5><p>通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,从typesBySubscriber移除subscriber。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123; </span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); </span><br><span class="line"><span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123; </span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123; </span><br><span class="line">        unsubscribeByEventType(subscriber, eventType); </span><br><span class="line">    &#125; </span><br><span class="line">  typesBySubscriber.remove(subscriber); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass()); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div></article>
      <nav class="pagination"></nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:janggwazkw@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/janggwa" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2016 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">JinGuo</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
