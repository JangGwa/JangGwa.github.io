{"meta":{"title":"jinguo's home","subtitle":null,"description":null,"author":"JinGuo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-03-26T01:41:28.409Z","updated":"2019-03-26T01:41:28.409Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"热爱技术，热爱运动的 sunshine boy."},{"title":"categories","date":"2019-03-13T14:14:04.000Z","updated":"2019-03-14T01:17:28.659Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"学习-ES6基础知识点","slug":"学习-ES6基础知识点","date":"2019-05-15T16:00:00.000Z","updated":"2019-05-21T01:43:42.404Z","comments":true,"path":"2019/05/16/学习-ES6基础知识点/","link":"","permalink":"http://yoursite.com/2019/05/16/学习-ES6基础知识点/","excerpt":"前言本篇文章介绍面试中经常问的ES6基础知识点。","text":"前言本篇文章介绍面试中经常问的ES6基础知识点。文章中的关联问题可以在面试官问了问题后自己进行引申这些相关话题，从而引导面试官询问自己擅长的部分。后续会持续推出HTML知识点、CSS知识点、JS进阶知识点、webpack知识点、react知识点、组件设计相关知识点、浏览器相关知识点、网络相关知识点、算法相关知识点等文章进行全面的知识梳理。 块级作用域Q: 如何理解let和const，和var有什么区别？A: let 和 const 没有变量提升、不能重复声明、不绑定全局作用域。关联Q: 如何理解临时性死区?关联A: JavaScript 引擎会扫描变量声明，会放入临时死区，如果发现如果在声明变量之前访问这些变量，会导致报错。关联Q: 有没有研究过babel是怎么编译let的?关联A: 如果有两个一样的变量名，会编译成不同的变量名，如果是循环中的申明，它会编译成两个方法，进行循环调用传入参数的方法。 箭头函数Q: 箭头函数有什么特性?A: 没有 this、没有 arguments、不能用 new 关键字调用、没有new.target、没有原型、没有 super。关联Q: 如何确定箭头函数的this?关联A: 通过查找作用域链来确定 this，也就是最近一层非箭头函数的this。 Symbol类型Q: Symbol 有哪些特性?A: Symbol的值表示独一无二的值、typeof 类型是 Symbol、不能使用 new 命令、Symbol 一个对象，调用的是对象的toString()、相同参数的 Symbol 函数返回值不相等、Symbol值不能与其他类型进行运算、Symbol 可以用于对象的属性名关联Q: 为什么不能使用new命令？关联A: 因为 Symbol 是原始类型，不是对象。关联Q: 可以用forin或者forof获取属性名吗？关联A: 只能用Object.getOwnPropertySymbols获取属性名 迭代器与forofQ: 什么是迭代器？A: 迭代器就是一个拥有 next 方法的对象，每次调用next()会返回一个 value 和 done 属性的结果对象。关联Q: forof可以遍历哪些对象，可以直接遍历一个普通对象吗？关联A: 数组、Set、Map、类数组对象、Generator 对象、字符串，forof可以遍历的本质是对象中有 Symbol.iterator 属性。 PromiseQ: 如何理解Promise?A: 优点：链式调用，解决回调的控制反转和回调地狱的问题，缺点： 无法取消 Promise，无法得知 pending 状态关联Q: Promise内部实现？关联A: 一般会让你手写 Promise 的 某一个函数，可以自己去实现一下整个 Promise，在文章最后有简单实现的代码。 classQ: 分别用es5和es6的方式实现继承？A: es6 比较简单，直接用 extends 实现。es5 比较典型的实现方式就是寄生组合继承，核心思想就是将父类的原型赋值给子类，并且将构造函数设置为子类。在文章最后有简单实现的代码。 模块化Q: 模块化有什么好处？为什么使用模块化？A: 解决命名冲突、提供复用性、提高代码可维护性。关联Q: 如何实现模块化？关联A: 可以使用立即执行函数实现模块化。关联Q: CommonJS和es Module有哪些区别？关联A: CommonJS 是同步导入，用于服务端；ES module 是异步导入，用于浏览器； CommonJS 输出的是对于值的拷贝，ES module 输出的是对值的引用；CommonJS 模块是运行时加载，ES module 模块是编译时输出接口 Promise 源码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167const PENDING = 'pending'const RESOLVED = 'resolved'const REJECTED = 'rejected'function MyPromise(fn) &#123; this.state = PENDING this.value = null this.resolvedCallbacks = [] this.rejectedCallbacks = [] function resolve(value) &#123; if (this.state === PENDING) &#123; this.state = RESOLVED this.value = value this.resolvedCallbacks.forEach(cb =&gt; cb(value)) &#125; &#125; function reject(value) &#123; if (this.state === PENDING) &#123; this.state = REJECTED this.value = value this.rejectedCallbacks.forEach(cb =&gt; cb(value)) &#125; &#125; try &#123; fn(resolve, reject) &#125; catch (e) &#123; reject(e) &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v onRejected = typeof onRejected === 'function' ? onRejected : e =&gt; &#123;throw e&#125; const that = this let promise2 = new Promise((resolve, reject) =&gt; &#123; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(that.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125;) that.rejectedCallbacks.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(that.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125;) &#125; if (this.state === RESOLVED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onFulfilled(this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125; if (this.state === REJECTED) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.value) resolvePromise(promise2, x, resolve, reject) &#125; catch(e) &#123; reject(e) &#125; &#125;) &#125; &#125;) return promise2&#125;function resolvePromise(promise2, x, resolve, reject) &#123; if(promise2 === x) &#123; reject(new TypeError('Error')) &#125; if (x &amp;&amp; typeof x === 'object' || typeof x === 'function') &#123; let called; try &#123; let then = x.then if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if (called) return called = true resolvePromise(promise2, y, resolve, reject) &#125;, e =&gt; &#123; if (called) return called = true reject(e) &#125;) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch(e) &#123; if (called) return called = true reject(e) &#125; &#125; else &#123; resolve(x) &#125;&#125;MyPromise.prototype.catch = function(onRejected) &#123; return this.then(null, onRejected)&#125;MyPromise.prototype.finally = function(callback) &#123; return this.then(value =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; value) &#125;, err =&gt; &#123; return Promise.resolve(callbakck()).then(() =&gt; &#123;throw err&#125;) &#125;)&#125;MyPromise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0 let result = [] if (promises.length === 0) &#123; resolve(result) &#125; else &#123; for(let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(data =&gt; &#123; result[i] = data if (++index === promises.length) resolve(result) &#125;, err =&gt; &#123; reject(err) return &#125;) &#125; &#125; &#125;)&#125;MyPromise.race = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; if (promises.length === 0) &#123; return &#125; else &#123; for(let i = 0; i &lt; promises.length; i++) &#123; Promise.resolve(promises[i]).then(data =&gt; &#123; resolve(data) return &#125;, err =&gt; &#123; reject(err) return &#125;) &#125; &#125; &#125;)&#125; 寄生组合继承12345678910111213function Parent(value) &#123; this.val = value&#125;Parent.prototype.getValue = function() &#123; console.log(this.val)&#125;function Child(value) &#123; Parent.call(this, value)&#125;Child.prototype = Object.create(Parent.prototype)Child.prototype.constructor = Childconst child = new Child(1)","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"学习-JS基础知识点","slug":"学习-JS基础知识点","date":"2019-05-02T16:00:00.000Z","updated":"2019-05-21T01:43:52.159Z","comments":true,"path":"2019/05/03/学习-JS基础知识点/","link":"","permalink":"http://yoursite.com/2019/05/03/学习-JS基础知识点/","excerpt":"","text":"前言本篇文章介绍面试中经常问的JS基础知识点。文章中的关联问题可以在面试官问了问题后自己进行引申这些相关话题，从而引导面试官询问自己擅长的部分。后续会持续推出HTML知识点、CSS知识点、ES6知识点、JS进阶知识点、webpack知识点、react知识点、组件设计相关知识点、浏览器相关知识点、网络相关知识点、算法相关知识点等文章进行全面的知识梳理。 基础类型和对象类型Q: 基础类型有哪些？A: 基础类型有 number、undefined、null、bollean、string、symbol。关联Q: 和对象类型的存储有什么区别？关联A: 基础类型存储在栈内存中，存储的是值，是没有函数可以调用的。对象类型存储在堆内存中，存储的是地址。关联Q: null是对象吗？关联A: 虽然typeof null输出的是object，但是null其实是基础类型。这个错误是因为JS的最初版本是32位系统，000开头代表的是对象，而null表示全零，所以被错误的判断为object typeof和instanceofQ: typeof能正确的判断类型吗？A: 对于基础类型，除了null其余的基础类型都能正确判断类型，对于对象类型，除了函数都会显示object，所以不能准确区分类型。关联Q: instanceof能正确的判断类型吗?关联A: instanceof可以准确的判断对象类型，因为内部机制是通过原型链来判断的。但是它不能区分基础类型，当然也可以写一个自定义类，修改Symbol.hasInstance属性来判断基础类型。 类型转换Q: == 和 === 有什么区别？A: ===不需要进行类型转换，只有类型相同，并且值相等时返回true,==需要进行类型转换比较。关联Q: 类型转换的规则是怎样的？关联A: 先判断类型是否相等，如果相等就判断值是否相等；判断类型是否是null或者undefined，如果是则返回true；判断类型是否是number和string,如果是则把string转成number；判断类型其中一方是否是boolean，如果是则把boolean转成number再进行比较；判断类型其中一方是否是object,且另一方是string、number、symbol如果是则把object转成原始类型在进行比较。对象转原始类型会调用内置的Symbol.toPrimitive函数。 thisQ: 如何正确判断this?A: this的绑定规则有四种：默认绑定、隐式绑定、硬绑定、new绑定。new绑定的优先级最高，然后是硬绑定，然后是隐式绑定，最后是默认绑定。关联Q: 箭头函数的this是什么？关联A: 箭头函数的this取决于包裹箭头函数的第一个普通函数的this。 闭包Q: 什么是闭包？A: 闭包就是能够访问另一个函数作用域下的变量的函数。关联Q: 闭包有哪些使用场景?关联A: 封装私有变量、模仿块级作用域、实现JS的模块。 深浅拷贝Q: 浅拷贝和深拷贝是什么？A: 浅拷贝只会拷贝所有属性值到新对象中，如果属性是对象拷贝的是地址。深拷贝会深层次的拷贝对象的值。关联Q: 如何实现浅拷贝和深拷贝？关联A: 浅拷贝可以通过Object.assign方法来实现，另外也可以通过...操作符来实现。深拷贝可以通过JSON.parse(JSON.stringify(object))来解决，但是这个方法会忽略undefined、symbol，且不能序列化函数，不能解决循环引用的对象。如果拷贝的对象含有内置类型不包含函数，也可以使用MessageChannel来实现。 原型Q: 如何理解原型？如何理解原型链？A: 每当定义一个对象时，对象都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。原型链就是多个对象通过proto连接了起来。通过原型链可以拥有定义在其他对象中的属性和方法。关联Q: 是不是所有函数都有prototype属性？关联A: Function.prototype.bind()就没有这个属性。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS类型与文法","slug":"书评-YDKJS类型与文法","date":"2019-03-13T16:00:00.000Z","updated":"2019-03-14T03:14:33.272Z","comments":true,"path":"2019/03/14/书评-YDKJS类型与文法/","link":"","permalink":"http://yoursite.com/2019/03/14/书评-YDKJS类型与文法/","excerpt":"第一章：类型JavaScript 定义了七种内建类型：null、undefined、boolean、number、string、object、symbol。","text":"第一章：类型JavaScript 定义了七种内建类型：null、undefined、boolean、number、string、object、symbol。typeof 操作符可以检测给定值的类型。12345678typeof undefined === \"undefined\"; // truetypeof true === \"boolean\"; // truetypeof 42 === \"number\"; // truetypeof \"42\" === \"string\"; // truetypeof &#123; life: 42 &#125; === \"object\"; // true// 在 ES6 中被加入的！typeof Symbol() === \"symbol\"; // true typeof 操作符是有 bug 的， 那就是 typeof null === “object”; // true 这个 bug 已经存在了近二十年，而且好像永远也不会被修复了，以为修复它可能会引起更多的 bug。 如果你想用 null 类型来测试 null 值，需要一个符合条件:123var a = null;(!a &amp;&amp; typeof a === \"object\"); // true 特别需要注意的是 typeof function(){} 是 “function”。 typeof 操作符总是返回字符串。 第二章：值Array 有两个点需要注意： 如果用 delete 删除 Array 上的元素，他只是移除这个值槽，不会更新 length 属性。 如果一个可以被强制转换为10进制 number 的 string 值被用作键的话，它会认为你想使用 number 索引而不是一个 string 键！ 类数组转换成数组一般使用以下两种方式： Array.prototype.slice.call(arguments) Array.from(arguments); JavaScript 的 number 的实现基于”IEEE 754”标准，通常被称为浮点。Javascript 明确使用了这个标准的“双精度” 针对 0.1 + 0.2 === 0.3 // false 这个问题的解释简单说是因为 0.1 和 0.2 的二进制表现形式是不精准的，所以他们相加时，结果不是精确的0.3. 测试是否是整数可以使用 Number.isInteger(),模拟实现如下12345if (!Number.isInteger) &#123; Number.isInteger = function(num) &#123; return typeof num == \"number\" &amp;&amp; num % 1 == 0; &#125;;&#125; 测试是否是安全整数可以使用 Number.isSafeInteger(),模拟实现如下123456if (!Number.isSafeInteger) &#123; Number.isSafeInteger = function(num) &#123; return Number.isInteger( num ) &amp;&amp; Math.abs( num ) &lt;= Number.MAX_SAFE_INTEGER; &#125;;&#125; 表达式 void __ 会“躲开”任何值，所以这个表达式的结果总是值 undefined。它不会修改任何已经存在的值；只是确保不会有值从操作符表达式中返回来。 在 ES6 中，有一个新工具可以用于测试两个值的绝对等价性，而没有任何这些例外。它称为 Object.is(..):1234567var a = 2 / \"foo\";var b = -3 * 0;Object.is( a, NaN ); // trueObject.is( b, -0 ); // trueObject.is( b, 0 ); // false Object.is()的模拟实现如下：1234567891011121314if (!Object.is) &#123; Object.is = function(v1, v2) &#123; // 测试 `-0` if (v1 === 0 &amp;&amp; v2 === 0) &#123; return 1 / v1 === 1 / v2; &#125; // 测试 `NaN` if (v1 !== v1) &#123; return v2 !== v2; &#125; // 其他情况 return v1 === v2; &#125;;&#125; 第三章：原生类型原生类型实际上就是内建函数，有以下几种 String()、Number()、Boolean()、Array()、Object()、Function()、RegExp()、Date()、Error()、Symbol() 第四章：强制转换在观察代码时如果一个类型转换明显是有意为之的，那么它就是“明确强制转换”，而如果这个类型转换是做为其他操作的不那么明显的副作用发生的，那么它就是“隐含强制转换”。12345var a = 42;var b = a + \"\"; // 隐含强制转换var c = String( a ); // 明确强制转换 JSON.stringify(..) 工具在遇到 undefined、function、和 symbol 时将会自动地忽略它们。如果在一个 array 中遇到这样的值，它会被替换为 null（这样数组的位置信息就不会改变）。如果在一个 object 的属性中遇到这样的值，这个属性会被简单地剔除掉。 但如果你试着 JSON.stringify(..) 一个带有循环引用的 object，就会抛出一个错误。 如果你打算 JSON 字符串化一个可能含有非法 JSON 值的对象，或者如果这个对象中正好有不适于序列化的值，那么你就应当为它定义一个 toJSON() 方法，返回这个 object 的一个 JSON 安全 版本。 宽松等价是==操作符，而严格等价是===操作符。 关于这两个操作符的一个非常常见的误解是：“==检查值的等价性，而===检查值和类型的等价性。” 正确的描述是：“==允许在等价性比较中进行强制转换，而===不允许强制转换”。 比较 null 和 undefiined，宽松等价两个相等 比较 number 和 string，把 string 转换成 number 比较 boolean 和其他，把 boolean 转换成 number 比较 object 和非 object，把 object 调用 ToPrimitive() 方法 第五章：文法JavaScript文法有相当多的微妙之处，我们作为开发者应当比平常多花一点儿时间来关注它。一点儿努力可以帮助你巩固对这个语言更深层次的知识。 语句和表达式在英语中有类似的概念 —— 语句就像句子，而表达式就像短语。表达式可以是纯粹的/自包含的，或者他们可以有副作用。 JavaScript文法层面的语义用法规则（也就是上下文），是在纯粹的语法之上的。例如，用于你程序中不同地方的{ }可以意味着块儿，object 字面量，（ES6）解构语句，或者（ES6）被命名的函数参数。 JavaScript有几种类型的错误，但很少有人知道它有两种类别的错误：“早期”（编译器抛出的不可捕获的）和“运行时”（可以try..catch的）。所有在程序运行之前就使它停止的语法错误都明显是早期错误，但也有一些别的错误。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJSthis与对象原型","slug":"书评-YDKJSthis与对象原型","date":"2019-03-12T16:00:00.000Z","updated":"2019-03-14T03:15:11.893Z","comments":true,"path":"2019/03/13/书评-YDKJSthis与对象原型/","link":"","permalink":"http://yoursite.com/2019/03/13/书评-YDKJSthis与对象原型/","excerpt":"第一章：this 是什么this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。 this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。","text":"第一章：this 是什么this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。 this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。this 既不是函数自身的引用，也不是函数词法作用域的引用。 this 实际上是在函数被调用时建立的一个绑定，它指向什么是完全由函数被调用的调用点来决定的。 首先展示一下 this 的动机和用途:12345678910111213141516171819202122function identify() &#123; return this.name.toUpperCase();&#125;function speak() &#123; var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting );&#125;var me = &#123; name: \"Kyle\"&#125;;var you = &#123; name: \"Reader\"&#125;;identify.call( me ); // KYLEidentify.call( you ); // READERspeak.call( me ); // Hello, I'm KYLEspeak.call( you ); // Hello, I'm READER 与使用 this 相反地，你可以明确地将环境对象传递给 identify() 和 speak().1234567891011function identify(context) &#123; return context.name.toUpperCase();&#125;function speak(context) &#123; var greeting = \"Hello, I'm \" + identify( context ); console.log( greeting );&#125;identify( you ); // READERspeak( me ); // Hello, I'm KYLE this 机制提供了更优雅的方式来隐含地传递一个对象引用，导致更加干净的API设计和更容易的复用。 第二章：this 豁然开朗首先我们展示一下调用栈和调用点：123456789101112131415161718192021222324function baz() &#123; // 调用栈是: `baz` // 我们的调用点是 global scope（全局作用域） console.log( \"baz\" ); bar(); // &lt;-- `bar` 的调用点&#125;function bar() &#123; // 调用栈是: `baz` -&gt; `bar` // 我们的调用点位于 `baz` console.log( \"bar\" ); foo(); // &lt;-- `foo` 的 call-site&#125;function foo() &#123; // 调用栈是: `baz` -&gt; `bar` -&gt; `foo` // 我们的调用点位于 `bar` console.log( \"foo\" );&#125;baz(); // &lt;-- `baz` 的调用点 在分析代码来寻找（从调用栈中）真正的调用点时要小心，因为它是影响 this 绑定的唯一因素。 那么调用点是如何决定在函数执行期间 this 指向哪里的。 我们有四种 this 绑定规则：默认绑定、隐含绑定、明确绑定、new 绑定。 判定 this 的步骤： 我们可以先判断函数是通过 new 被调用的嘛？如果是， this 就是新构建的函数。 然后判断函数是通过 call 或 apply 被调用，甚至是隐藏在 bind 硬绑定中吗？ 如果是，this 就是那个被明确指定的对象。 然后判断函数是通过环境对象被调用的嘛？ 如果是，this 就是那个环境对象。 否则，使用默认的 this。如果在 strict mode 下，就是 undefined，否则就是 global 对象。 如果传递 null 或 undefined 作为 call、 apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。这样会带来一些潜在的危险。如果你这样处理一些函数调用，而且那些函数确实使用了 this 引用，那么默认绑定规则意味着它可能会不经意间引用 global 对象。很显然，这样的陷阱会导致多种非常难诊断和追踪的 bug。安全的做法是通过 Object.create(null) 来作为绑定参数。 我们知道硬绑定是一种通过将函数强制绑定到特定的 this 上，来防止函数调用在不经意间退回到默认绑定的策略。问题是，硬绑定极大地降低了函数的灵活性，阻止我们手动使用隐含绑定或后续的明确绑定来覆盖 this。 软化绑定的思路就是为默认绑定提供不同的默认值，同时保持函数可以通过隐含绑定或明确绑定技术来手动绑定 this。 下面我们就分别展示硬绑定和软化绑定的代码实现硬绑定12345678910111213141516171819202122232425262728if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== \"function\") &#123; // 可能的与 ECMAScript 5 内部的 IsCallable 函数最接近的东西， throw new TypeError( \"Function.prototype.bind - what \" + \"is trying to be bound is not callable\" ); &#125; var aArgs = Array.prototype.slice.call( arguments, 1 ), fToBind = this, fNOP = function()&#123;&#125;, fBound = function()&#123; return fToBind.apply( ( this instanceof fNOP &amp;&amp; oThis ? this : oThis ), aArgs.concat( Array.prototype.slice.call( arguments ) ) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 软绑定12345678910111213141516171819if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; var fn = this, curried = [].slice.call( arguments, 1 ), bound = function bound() &#123; return fn.apply( (!this || (typeof window !== \"undefined\" &amp;&amp; this === window) || (typeof global !== \"undefined\" &amp;&amp; this === global) ) ? obj : this, curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); return bound; &#125;;&#125; 第三章：对象对象是大多是 JS 程序依赖的基本构建块儿。 一个常见的错误论断是“JavaScript中的一切都是对象”。这明显是不对的。比如 string、number、boolean、null、undefined 这几个简单基本类型自身不是 object。 一个 JSON 安全的对象可以简单地这样复制：1var newObj = JSON.parse( JSON.stringify( someObj ) ); 浅拷贝可以使用 Object.assign()来实现。 所有的属性都用属性描述符来描述，通过Object.getOwnPropertyDescriptor()来查看，会发现一个对象不仅只有 value 值，还有 writable、enumerable 和 configurable。 当然我们也可以使用Object.defineProperty()来添加新属性或使用期望的性质来修改既存的属性。 writable 控制着改变属性值的能力。 configurable 控制着该对象是否可配置 enumerable 控制该对象是否可枚举 防止扩展：Object.preventExtensions()可以防止一个对象被添加新的属性，同时保留其他既存的对象属性。 封印：Object.seal()既不能添加更多的属性，也不能重新配置或删除既存属性，但是你依然可以修改他们的值。 冻结：Object.freeze()阻止任何对对象或对象直属属性的改变。 属性不必非要包含值 —— 它们也可以是带有 getter/setter 的“访问器属性”。123456789101112131415var myObject = &#123; // 为 `a` 定义 getter get a() &#123; return this._a_; &#125;, // 为 `a` 定义 setter set a(val) &#123; this._a_ = val * 2; &#125;&#125;;myObject.a = 2;myObject.a; // 4 你也可以使用 ES6 的 for..of 语法，在数据结构（数组，对象等）中迭代值，它寻找一个内建或自定义的 @@iterator 对象，这个对象由一个 next() 方法组成，通过这个 next() 方法每次迭代一个数据。123456789101112131415161718192021222324252627282930313233343536var myObject = &#123; a: 2, b: 3&#125;;Object.defineProperty( myObject, Symbol.iterator, &#123; enumerable: false, writable: false, configurable: true, value: function() &#123; var o = this; var idx = 0; var ks = Object.keys( o ); return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: (idx &gt; ks.length) &#125;; &#125; &#125;; &#125;&#125; );// 手动迭代 `myObject`var it = myObject[Symbol.iterator]();it.next(); // &#123; value:2, done:false &#125;it.next(); // &#123; value:3, done:false &#125;it.next(); // &#123; value:undefined, done:true &#125;// 用 `for..of` 迭代 `myObject`for (var v of myObject) &#123; console.log( v );&#125;// 2// 3 第四章：混合（淆）“类”的对象类描述了一种特定的代码组织和结构形式，他有实例化、继承和多态等机制。 mixin 模式常用于在某种程度上模拟类的拷贝行为，但是这通常导致像显式假想多态那样（OtherObj.methodName.call(this, …)）难看而且脆弱的语法，这样的语法又常导致更难懂和更难维护的代码。 明确的 mixin 和类拷贝又不完全相同，因为对象（和函数！）仅仅是共享的引用被复制，不是对象/函数自身被复制。 第五章：原型每个普通的 [[prototype]] 链的最顶端，是内建的 Object.prototype。 我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在于 myObject，但存在于 myObject 的 [[Prototype]] 链的更高层时： 如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个遮蔽属性。 如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是不允许的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。 如果一个 foo 在 [[Prototype]] 链的高层某处被找到，而且它是一个 setter，那么这个 setter 总是被调用。没有 foo 会被添加到（也就是遮蔽在）myObject 上，这个 foo setter 也不会被重定义。 我们通过 instanceof 或者 isPrototypeOf 方法来判断一个对象是否存在某个原型链中。 proto 的代码实现如下12345678910Object.defineProperty( Object.prototype, \"__proto__\", &#123; get: function() &#123; return Object.getPrototypeOf( this ); &#125;, set: function(o) &#123; // ES6 的 setPrototypeOf(..) Object.setPrototypeOf( this, o ); return o; &#125;&#125; ); Object.create() 的代码实现如下1234567if (!Object.create) &#123; Object.create = function(o) &#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125;;&#125; 第六章：行为委托行为委托意味着对象彼此是对等的，在它们自己当中相互委托，而不是父类与子类的关系。JavaScript 的 [[Prototype]] 机制的设计本质，就是行为委托机制。这意味着我们可以选择挣扎着在 JS 上实现类机制，也可以欣然接受 [[Prototype]] 作为委托机制的本性。 面线对象和行为委托的思维模式比较如下：面向对象的代码形式：123456789101112131415161718192021function Foo(who) &#123; this.me = who;&#125;Foo.prototype.identify = function() &#123; return \"I am \" + this.me;&#125;;function Bar(who) &#123; Foo.call( this, who );&#125;Bar.prototype = Object.create( Foo.prototype );Bar.prototype.speak = function() &#123; alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = new Bar( \"b1\" );var b2 = new Bar( \"b2\" );b1.speak();b2.speak(); 面向行为委托的代码形式：12345678910111213141516171819202122var Foo = &#123; init: function(who) &#123; this.me = who; &#125;, identify: function() &#123; return \"I am \" + this.me; &#125;&#125;;var Bar = Object.create( Foo );Bar.speak = function() &#123; alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = Object.create( Bar );b1.init( \"b1\" );var b2 = Object.create( Bar );b2.init( \"b2\" );b1.speak();b2.speak();","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS作用域与闭包","slug":"书评-YDKJS作用域和闭包","date":"2019-02-17T16:00:00.000Z","updated":"2019-03-14T03:15:07.051Z","comments":true,"path":"2019/02/18/书评-YDKJS作用域和闭包/","link":"","permalink":"http://yoursite.com/2019/02/18/书评-YDKJS作用域和闭包/","excerpt":"第一章 什么是作用域？几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力。作用域就是定义如何在某些位置存储变量，以及如何在稍后找到这些变量。","text":"第一章 什么是作用域？几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力。作用域就是定义如何在某些位置存储变量，以及如何在稍后找到这些变量。 编译器理论编译的三个步骤 1.分词/词法分析：将一连串的字符打断成有意义的片段，称为 token，例子：var a = 2;=&gt; var, a, =, 2, ;。 2.解析：将一个 token 的流转换成一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为抽象语法树（AST） 3.代码生成：这个处理将抽象语法树转换为可执行的代码。 JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中。对于 JavaScript 来说，在许多情况下，编译发生在代码执行前的仅仅几微秒之内。为了确保最快的性能，JS 引擎使用了 JIT等等 理解作用域引擎：负责从始至终的编译和执行我们的 JavaScript 程序。编译器：引擎的朋友之一；处理所有解析和代码生成的活儿。作用域：引擎的另一个朋友；收集并维护一张所有被声明的标识符的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。 对于 var a = 2;这个语句，编译器将会这样处理： 1.遇到var a，编译器让作用域去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器就忽略这个声明并继续前进。否则，编译器就让作用域去为这个作用域集合声明一个称为 a 的新变量。 2.然后编译器为引擎生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎就使用这个变量。如果没有，引擎会喊出一个错误。 嵌套的作用域嵌套的作用域就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。 遍历嵌套作用域的简单规则：引擎从当前执行的作用域开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。 第二章 词法作用域作用域的工作方式有两种占统治地位的模型。其中第一种是最常见的词法作用域，另一种是动态作用域。 JavaScript 所采用的作用域模型是词法作用域。 词法作用域是在词法分析时被定义的作用域。 欺骗词法作用域：eval 函数和 with 关键字的使用。 欺骗词法作用域的使用会导致更低下的性能。因为 JS 引擎的一些优化原理都归结在实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明在什么位置。如果发现一个 eval 或是 with，它实质上就不得不假定自己知道的所有标识符的位置可能是无效的。 第三章 函数与块儿作用域函数作用域函数中的作用域也就是声明的每一个函数都为自己创建了一个作用域。立即调用函数表达式可以生成一个自己的作用域。 块儿作用域ES6引入了 let 和 const，它们都会创建一个块儿作用域。let 做出的声明不会在他们所出现的块儿的作用域中提升。 第四章 提升在代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。以下是两个例子123a = 2;var a;console.log( a ); // 2 12console.log( a ); // undefinedvar a = 2; 函数声明会被提升，但是函数表达式不会。12345foo();function foo() &#123; console.log( a ); // undefined var a = 2;&#125; 12345foo(); // 不是 ReferenceError， 而是 TypeError! 因为变量 foo 被提升了，但是值为 undefinedvar foo = function bar() &#123; // ...&#125;; 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 这个代码被引擎解释执行为1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 这里的一个注意点就是 var foo 是一个重复的声明，会被忽略。 第五章 作用域闭包闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。以下例子是一个典型的闭包案例123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 -- 哇噢，看到闭包了，伙计。 我们生活中经常使用到的闭包1234567function wait(message) &#123; setTimeout( function timer()&#123; console.log( message ); &#125;, 1000 );&#125;wait( \"Hello, closure!\" ); 还有模块就是利用了闭包的力量，我们看下面的代码12345678910111213141516171819202122function CoolModule() &#123; var something = \"cool\"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( \" ! \" ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS入门与进阶","slug":"书评-YDKJS入门与进阶","date":"2019-02-14T16:00:00.000Z","updated":"2019-03-14T03:14:44.333Z","comments":true,"path":"2019/02/15/书评-YDKJS入门与进阶/","link":"","permalink":"http://yoursite.com/2019/02/15/书评-YDKJS入门与进阶/","excerpt":"第一章：进入编程代码代码是一组告诉计算机要执行什么任务的特殊指令。通常保存在文本文件中，也可以在浏览器的\b开发者控制台中直接键入代码。","text":"第一章：进入编程代码代码是一组告诉计算机要执行什么任务的特殊指令。通常保存在文本文件中，也可以在浏览器的\b开发者控制台中直接键入代码。 语句一组单词，数字，和执行一种具体任务的操作符构成了一个语句。语句包含了变量、字面量、操作符。例如a = b * 2; 就是一个语句，而 a、b 是变量，2是字面量，=、* 是操作符。 表达式一个表达式是一个引用，指向变量或值，或者一组用操作符组合的变量和值。 123452 -&gt; 字面量表达式b -&gt; 变量表达式b * 2 -&gt; 算数表达式a = b * 2 -&gt; 赋值表达式alert(a) -&gt; 函数表达式 执行一个程序\bJavaScript引擎实际上在即时地自上而下的编译程序然后立即运行编译好的代码。 第二章：进入 JavaScript值与类型内建类型有：string，number，boolean，null，undefined，symbol，object。通常我们可以用 typeof 来判断类型，但是 JS 中存在一个 bug，就是 typeof null 为 object，这个可以通过 Object.prototype.toString.call(null) 来进行判断。 值的比较true 和 false‘’, 0, -0, NaN, null, undefined, false 转 Boolean 为 false，其余都是true。 等价性不准确的描述：== 检查值的等价性而 === 检查值和类型两者的等价性。合理的描述： == 在允许强制转化的条件下检查值的等价性， === 是在不允许强制转换的条件下检查值的等价性。 this 标识符123456789101112131415161718192021function foo() &#123; console.log( this.bar );&#125;var bar = \"global\";var obj1 = &#123; bar: \"obj1\", foo: foo&#125;;var obj2 = &#123; bar: \"obj2\"&#125;;// --------foo(); // \"global\"obj1.foo(); // \"obj1\"foo.call( obj2 ); // \"obj2\"new foo(); // undefined foo() 最终在非 strict 模式中将 this 设置为全局对象 —— 在 strict 模式中，this 将会是 undefined 而且你会在访问 bar 属性时得到一个错误 —— 所以 this.bar 的值是 global。 obj1.foo() 将 this 设置为对象 obj1。 foo.call(obj2) 将 this 设置为对象 obj2。 new foo() 将 this 设置为一个新的空对象。原型它的最简单的方法是使用称为Object.create(..)的内建工具。1234567891011var foo = &#123; a: 42&#125;;// 创建 `bar` 并将它链接到 `foo`var bar = Object.create( foo );bar.b = \"hello world\";bar.b; // \"hello world\"bar.a; // 42 &lt;-- 委托到 `foo` 旧的与新的有两种主要的技术可以将新的JavaScript特性“带到”老版本的浏览器中：填补和转译。 填补ES6定义了一个称为Number.isNaN(..)的工具，来为检查NaN值提供一种准确无误的方法12345if (!Number.isNaN) &#123; Number.isNaN = function isNaN(x) &#123; return x !== x; &#125;;&#125; 优秀填补例子： ES5-Shim 和 ES6-Shim 转译ES6增加了一个称为“默认参数值”的新特性。123456function foo(a = 2) &#123; console.log( a );&#125;foo(); // 2foo( 42 ); // 42 转译器会将它转换为老版本语法1234function foo() &#123; var a = arguments[0] !== (void 0) ? arguments[0] : 2; console.log( a );&#125; 优秀转译器例子： Babel 和 Traceur 第三章：进入 YDKJS作用域与闭包JS 是“解释型语言”因此是不被编译的，这是错误的。JS 引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。闭包的一个重要应用是模块模式。 this 与对象原型最大的谬误之一是认为 this 关键字指代它所出现的函数，这是错误的。this 关键字是根据函数如何被执行而动态绑定的。 类型与文法理解强制转换，而不是杜绝它的存在。 异步与性能Prmise 是一个“未来值”的一种与时间无关的包装，它让你推理并组合这些未来值而不必关心它们是否已经准备好。另外，它们通过将回调沿着一个可信赖和可组装的 promise 机制传递，有效地解决了 IoC 信任问题。Generator给JS函数引入了一种新的执行模式，generator可以在yield点被暂停而稍后异步地被继续。这种“暂停-继续”的能力让generator在幕后异步地被处理，使看起来同步，顺序执行的代码成为可能。如此，我们就解决了回调的非线性，非本地跳转的困惑，并因此使我们的异步代码看起来是更容易推理的同步代码。 ES6与未来很多值得一读的激动人心的ES6特性：结构，参数默认值，symbol，简洁方式，计算属性，箭头函数，块儿作用域，promise，generator，iterator，模块，代理，weakmap等。JavaScript 的未来是光明的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"学习-TypeScript入门","slug":"学习-TypeScript入门","date":"2019-02-12T16:00:00.000Z","updated":"2019-03-14T03:13:57.498Z","comments":true,"path":"2019/02/13/学习-TypeScript入门/","link":"","permalink":"http://yoursite.com/2019/02/13/学习-TypeScript入门/","excerpt":"什么是 TypeScriptTypeScript 是 JavaScript 的超集，主要提供了类型系统和对 ES6 的支持。它编译出来是 JavaScript，可以运行在任何浏览器上。","text":"什么是 TypeScriptTypeScript 是 JavaScript 的超集，主要提供了类型系统和对 ES6 的支持。它编译出来是 JavaScript，可以运行在任何浏览器上。 TypeScript 的优点 增加了代码的可读性和可维护性（类型系统、编译报错、代码补全、接口提示等） TypeScript 非常包容（类型推论、定义一切类型、兼容三方库等） TypeScript 拥有活跃的社区（Angular2 是 TypeScript 编写，大部分三方库提供 TypeScript 类型定义文件）TypeScript 的缺点 有一定的学习成本（接口、泛型等） 会增加一些开发成本（多写一些类型的定义） TypeScript 安装命令行： npm install -g typescript安装完成后会在全局环境安装tsc\b命令，编译一个 typescript 文件直接用命令 tsc xxx.ts 即可。 TypeScript 使用原始数据类型原始数据类型包括：布尔型、数值型、字符串、null、undefined\b、Symbol。 布尔值let isBoolean: boolean = false; 数值let num: number = 1; 字符串let str: string = &#39;str&#39;; 空值123function alertName(): void &#123; alert('My Name is xxx');&#125; Null 和 Undefined1let u: undefined = undefined; 1let n: null = null; 任意值任意值用来表示允许赋值为任意类型。12let something: any = 'xxx';something = 1; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。 联合类型联合类型表示取值可以为多种类型中的一种。123let something: string | number;something = 'xxx';something = 1; 对象的类型–接口在 TypeScript 中，我们使用接口来定义对象的类型。12345678interface Person &#123; name: string; age: number;&#125;let ingot: Person = &#123; name: 'ingot', age: 25&#125; 定义的接口首字母大写。定义的变量比接口少一些属性和多一些属性都是不允许的。 可选属性1234567interface Person &#123; name: string; age?: number;&#125;let ingot: Person = &#123; name: 'ingot'&#125; 任意属性12345678interface Person &#123; name: string; [propName: string]: any;&#125;let ingot: Person = &#123; name: 'ingot', age: 11&#125; 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性。 只读属性1234interface Person &#123; readonly id: number, name: string&#125; 数组的类型类型+方括号表示法1let arr: number[] = [1, 2, 3, 4, 5]; 数组泛型1let arr: Array&lt;number&gt; = [1, 2, 3, 4, 5]; 用接口表示数组1234interface NumberArray &#123; [index: number]: number&#125;let arr: NumberArray = [1, 2, 3, 4, 5]; 函数的类型函数声明123function sum(x: number, y: number): number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的 函数表达式123let sum:(x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125; 类型别名我们使用 type 创建类型别名。1type Name = string;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"学习-View的事件分发机制","slug":"学习-View的事件分发机制","date":"2016-08-12T16:00:00.000Z","updated":"2019-03-14T03:25:37.949Z","comments":true,"path":"2016/08/13/学习-View的事件分发机制/","link":"","permalink":"http://yoursite.com/2016/08/13/学习-View的事件分发机制/","excerpt":"1.View点击事件的传递规则首先,用户触摸屏幕的时候系统必须对事件做出相应反应.而这个事件就是产生一个MotionEvent然后按照一定的规则传递给每一个View去进行相应的处理.这就是我们所谓的事件分发了.","text":"1.View点击事件的传递规则首先,用户触摸屏幕的时候系统必须对事件做出相应反应.而这个事件就是产生一个MotionEvent然后按照一定的规则传递给每一个View去进行相应的处理.这就是我们所谓的事件分发了.点击事件的分发主要设计一下几个主要的方法: 用来进行事件的分发.如果有事件传递给当前的View,那么该View一定会去调用这个方法 返回值受当前View的onTouchEvent和下级View的dispatchTouchEvent的影响 返回值表示当前的事件时候已经被处理完成 1public boolean dispatchTouchEvent(MotionEvent e) 这个方法在上面那个方法中内部调用,用来判断是否拦截这个事件 如果当前View拦截了某个事件 那么在同一个事件序列中就不会再次被调用 返回值表示是否拦截当前事件1public boolean onInterceptTouchEvent(MotionEvent e) 也是在第一个方法中去调用 用来处理拦截下来的事件 返回值为真表示该事件已经被处理 否则 没有处理 在同一事件序列中View无法再次接收到事件1public boolean onTouchEvent(MotionEvent e) 可以用一段伪代码来表示一下三者的关系:123456789public boolean dispatchTouchEvent(MotionEvent e) boolean consume = false; if (onInterceptTouchEvent(e)) consume = onTouchEvent(e) &#125; else &#123; consume = childView.dispathcTouchEvent(e) &#125; return consume;&#125; 从上面的代码中我们基本可以总结出这样的结论:对于一个根ViewGroup来说,当接收到一个MotionEvent的时候:调用dispatchTouchEvent方法调用onInterceptTouchEvent方法返回值为true,则表示拦截当前事件,调用onTouchEvent来处理这个事件返回值为false,则当前事件将会被传递给childView,childView继续调用dispatchTouchEvent方法。如此往复,直至事件被处理.当一个View需要处理一个事件的时候如果该View设置了onTouchListener,则会调用onTouch方法如果onTouch方法返回false,则去调用onTouchEvent如果设置了onClickListener,那么在onTouchEvent方法中将会调用onClick方法。反之,onTouchEvent则不会被调用 当一个事件产生的时候,它的传递过程遵循这样的过程:Activity-&gt;Windows-&gt;View;事件总是先传递给Activity,Activity在传递给Windows,Windows在传递给View;如果View将事件处理了,则该事件相应就结束了.否则,事件将一级一级的继续返回,最终会传递给Activity的onTouchEvent处理.12345@Overridepublic boolean onTouchEvent(MotionEvent event) &#123; Toast.makeText(MainActivity.this, event.getAction() + \"我是Activity\", Toast.LENGTH_SHORT).show(); return super.onTouchEvent(event);&#125; 当你没有给任何控件设置相应事件的时候(也就是都会返回false),那么你就会看到Activity的onTouchEvent被调用了.在开发艺术这本书中提到了几个结论:1.同一个事件序列是指手指接触屏幕那一刻起,到手指离开屏幕那一刻结束,在这个过程中所有产生的事件都属于这一个事件序列.包括一个ACTION_DOWN,一个ACTION_UP和n个ACTION_MOVE; 2.某一个View一旦决定拦截事件,那么这一事件序列都只能由它来处理. 这个结论认真想了一下,似乎有点问题;假如这个View我设置了onTouchListener,但是我依然返回false,这个事件序列仍然会传递给父View,当然了,这个View也只能接收到一个ACTION_DOWN事件,ACTION_UP和ACTION_MOVE不会接收到.假如这个View同时还设置了onClickListener,onTouchEvent返回false的时候事件会交给onTouchEvent处理这个事件,不会在交给父View处理了.这个问题还是需要结合源码来看一下;3.某个View一旦开始处理一个事件,如果它不消耗ACTION_DOWN事件,那么同一时间序列也不会交给他来处理了. 4.如果View不消耗ACTION_DWON以外的事件,那么这个点击事件就会消失,不会在交还给父View处理.最后会交回activity处理. 5.ViewGroup默认不拦截任何事件,他的onInterceptTouch方法默认返回false;View没有onInterceptTouch方法,收到事件他的onTouchEvent事件就会被调用. 6.View的onTouchEvent默认都会消耗事件(返回true),除非他是不可点击的(clickable和龙Clickable同时为false).View的longClickable默认都是false,clickable分情况. 2.Activity对事件的分发点击事件用MotionEvent来表示,当点击事件发生的时候,事件最先传递给当前Activity,由Activity的dispatchTouchEvent来进行事件派发,具体工作是由Activity内部的Windows来处理的.Windows会将事件传递给decor view,即当前View的root view.先看一下Activity的dispatchTouchEvent源码:123456789public boolean diapatchTouchEvent(MotionEvent e) &#123; if (e.getAction() == MotionEvent.ACTION_DOWN) &#123; onUserInteraction(); &#125; if (getWindows.superDispatchTouchEvent()) &#123; return true; &#125; return onTouchEvent(e);&#125; 这里有个onUserInteraction方法,点进去发现这个方法是一个空方法,文档是这样写的: Called whenever a key, touch, or trackball event is dispatched to the activity. Implement this method if you wish to know that the user has interacted with the device in some way while your activity is running. This callback and onUserLeaveHint() are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. All calls to your activity’s onUserLeaveHint() callback will be accompanied by calls to onUserInteraction(). This ensures that your activity will be told of relevant user activity such as pulling down the notification pane and touching an item there. Note that this callback will be invoked for the touch down action that begins a touch gesture, but may not be invoked for the touch-moved and touch-up actions that follow. 大体意思就是说onUserInteraction是帮助我们知道用户开始和屏幕进行交互的回调函数.另外,还会和onUserLeaveHint一起更加智能的管理状态栏通知. Called as part of the activity lifecycle when an activity is about to go into the background as the result of user choice. For example, when the user presses the Home key, onUserLeaveHint() will be called, but when an incoming phone call causes the in-call Activity to be automatically brought to the foreground, onUserLeaveHint() will not be called on the activity being interrupted. In cases when it is invoked, this method is called right before the activity’s onPause() callback. This callback and onUserInteraction() are intended to help activities manage status bar notifications intelligently; specifically, for helping activities determine the proper time to cancel a notfication. 这里这两个方法对我们不是很重要了,根据分析可以知道,activity通过windows来分发事件,当所有的view都没有接收处理事件的时候,activity就会自己调用自己的onTouchEvent()来处理这个事件了.继续看getWindows.superDispatchTouchEvent(),window是个抽象类, Abstract base class for a top-level window look and behavior policy. An instance of this class should be used as the top-level view added to the window manager. It provides standard UI policies such as a background, title area, default key processing, etc. The only existing implementation of this abstract class is android.view.PhoneWindow, which you should instantiate when needing a Window. 根据文档的描述,我们可以知道window的唯一实现类是android.view.PhoneWindow,那么他的dispatchTouchEvent是怎么实现的呢?1234//PhoneWindow#superDispatchTouchEventpublic boolean superDispatchTouchEvent(MotionEvent e) &#123; return mDecor.superDispatchTouchEvent(e);&#125; 这里的思路很清晰了,直接分发给mDecor处理,那么DecorView是什么东西呢?关于activity的层次点击这里12345678910 //this is the top-level view of the window,containing the window decor(装饰)private final class DecorView extends FrameLayout implements RootViewSurfaceTaker &#123; private DecorView mDecor; @Override public final View getDecorView() &#123; if (null == mDecor) &#123; installDecor(); &#125; return mDecor;&#125; 到了这事件会继续分发,到我们通过setContentView设置的ViewGroup那里继续处理. 3.ViewGroup对事件的分发123456789101112131415// Check for interception.final boolean intercepted;if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) &#123; final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) &#123; intercepted = onInterceptTouchEvent(ev); ev.setAction(action); // restore action in case it was changed &#125; else &#123; intercepted = false; &#125;&#125; else &#123; // There are no touch targets and this action is not an initial down // so this view group continues to intercept touches. intercepted = true;&#125; 这段代码是来判断是否要来拦截当前的点击事件的.可以看出当这个事件是一个事件序列的开端,也就是一个ACTION_DOWN,就用去调用onInterceptTouch方法去判断是否要去拦截这个事件;或者当mFirstTouchTarget不为空的时候,也会去判断.相反,就不会拦截了.这也说明了一个事件如果View不去处理他的ACTION_DWON事件为什么就能在去处理其他的事件了.当ViewGroup不处理事件要继续分发的时候代码是这样的:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129final int childrenCount = mChildrenCount;if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;final float x = ev.getX(actionIndex);final float y = ev.getY(actionIndex);// Find a child that can receive the event.// Scan children from front to back.final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();final boolean customOrder = preorderedList == null&amp;&amp; isChildrenDrawingOrderEnabled();final View[] children = mChildren;for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // If there is a view that has accessibility focus we want it // to get the event first and if not handled we will perform a // normal dispatch. We may do a double iteration but this is // safer given the timeframe. if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue;&#125;newTouchTarget = getTouchTarget(child);if (newTouchTarget != null) &#123;// Child is already receiving touch within its bounds.// Give it the new pointer in addition to the ones it is handling. newTouchTarget.pointerIdBits |= idBitsToAssign; break;&#125;resetCancelNextUpFlag(child);if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;// Child wants to receive touch within its bounds. mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) &#123;// childIndex points into presorted list, find original index for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break;&#125;// The accessibility focus didn't handle the event, so clear// the flag and do a normal dispatch to all children.ev.setTargetAccessibilityFocus(false);&#125;if (preorderedList != null) preorderedList.clear();&#125; 逻辑也比清晰,遍历ViewGroup的所有子View,找出能接受事件的所有元素;要满足两个条件:1.坐标是否落在子View中2.是否正在播放动画.满足这两个条件,就会分发给他来处理,要是返回了true就表示事件已经被处理,mFirstTouchTarget就会被赋值并终止此次分发,否则继续分发过程. 4.View对点击事件的处理过程12345678910111213141516171819202122232425//View#dispatchTouchEventif (onFilterTouchEventForSecurity(event)) &#123;//noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123; result = true; &#125; if (!result &amp;&amp; onTouchEvent(event)) &#123; result = true; &#125;&#125; 这里相对比较简单,首先判断是否设置了onTouchListener,如果设置了就去调用onTouch方法,如果返回了false,则去调用onTouchEvent方法; 在view设置了onClickListener或者onLongClickListener后,会自动将CLICKABLE或者LONG_CLICKABLE变成ture; 最后三张图十分清晰效果图如下：View不处理事件流程图（View没有消费事件）View处理事件事件拦截 附录以后每个知识点的实践学习代码会上传到我的GitHub,欢迎大家一起学习-.-~","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]},{"title":"学习-EventBus源码分析","slug":"学习-EventBus源码分析","date":"2016-08-02T16:00:00.000Z","updated":"2019-03-14T06:11:01.467Z","comments":true,"path":"2016/08/03/学习-EventBus源码分析/","link":"","permalink":"http://yoursite.com/2016/08/03/学习-EventBus源码分析/","excerpt":"简述EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息。优点是开销小，代码更优雅，以及将发送者和接收者解耦。","text":"简述EventBus是一款针对Android优化的发布/订阅事件总线。主要功能是替代Intent,Handler,BroadCast在Fragment，Activity，Service，线程之间传递消息。优点是开销小，代码更优雅，以及将发送者和接收者解耦。 基本使用1.新建一个类，AnyEventType。可以是网络请求返回的字符串，也可以是某个开关状态，也可以是空。123public class AnyEventType &#123; public AnyEventType()&#123;&#125; &#125; 2.注册订阅者1EventBus.getDefault().register(this); 3.发送事件1EventBus.getDefault().post(new AnyEventType event); 4.编写响应事件订阅方法1234@Subscribe(threadMode = ThreadMode.BACKGROUND, sticky = true, priority = 100)public void hello(String str) &#123;&#125; 这里说明一下3.0之后可以通过@Subscribe注解,来确定运行的线程threadMode,是否接受粘性事件sticky以及事件优先级priority,而且方法名不在需要onEvent开头,所以又简洁灵活了不少. 5.解除注册1EventBus.getDefault().unregister(this); 源码解析1.新建EventBus 默认可通过静态函数 getDefault 获取单例 12345678public static EventBus getDefault() &#123; if (defaultInstance == null) &#123; synchronized (EventBus.class) &#123; if (defaultInstance == null) &#123; defaultInstance = new EventBus(); &#125;&#125;&#125;return defaultInstance;&#125; EventBusBuilder 新建一个 EventBus 123public static EventBusBuilder builder() &#123; return new EventBusBuilder();&#125; 构造函数新建一个EventBus 123public EventBus() &#123; this(DEFAULT_BUILDER);&#125; 2.registerregister 函数中会先根据订阅者类名去subscriberMethodFinder中查找当前订阅者所有事件响应函数，然后循环每一个事件响应函数，依次执行subscribe 函数123456789public void register(Object subscriber) &#123; subscriberClass = subscriber.getClass();List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass); synchronized (this) &#123; for (SubscriberMethod subscriberMethod : subscriberMethods) &#123; subscribe(subscriber, subscriberMethod); &#125; &#125; &#125; 3.subscribe源码太长就不全部贴出来了 1.首先通过subscriptionsByEventType得到该事件类型所有订阅者信息队列，根据优先级将当前订阅者信息插入到订阅者队列subscriptionsByEventType中；如果添加过就抛出异常。123456789CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);if (subscriptions == null) &#123; subscriptions = new CopyOnWriteArrayList&lt;&gt;(); subscriptionsByEventType.put(eventType, subscriptions);&#125; else &#123; if (subscriptions.contains(newSubscription)) &#123; throw new EventBusException(\"Subscriber \" + subscriber.getClass() + \" already registered to event \"+ eventType); &#125;&#125; 2.在typesBySubscriber中得到当前订阅者订阅的所有事件队列，将此事件保存到队列typesBySubscriber中，用于后续取消订阅；12345List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber); if (subscribedEvents == null) &#123; subscribedEvents = new ArrayList&lt;&gt;(); typesBySubscriber.put(subscriber, subscribedEvents); &#125; 3.检查这个事件是否是 Sticky 事件，如果是则立即分发sticky事件12345678910111213141516if (subscriberMethod.sticky) &#123; //eventInheritance 表示是否分发订阅了响应事件类父类事件的方法 if (eventInheritance) &#123; Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet(); for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123; Class&lt;?&gt; candidateEventType = entry.getKey(); if (eventType.isAssignableFrom(candidateEventType)) &#123; Object stickyEvent = entry.getValue(); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; &#125; else &#123; Object stickyEvent = stickyEvents.get(eventType); checkPostStickyEventToSubscription(newSubscription, stickyEvent); &#125; &#125; 4.post首先得到当前线程的 post 信息PostingThreadState，其中包含事件队列，将当前事件添加到其事件队列中，然后循环调用postSingleEvent 函数发布队列中的每个事件。123456789101112131415161718public void post(Object event) &#123; PostingThreadState postingState = currentPostingThreadState.get(); List&lt;Object&gt; eventQueue = postingState.eventQueue; eventQueue.add(event); if (!postingState.isPosting) &#123; postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper(); postingState.isPosting = true; if (postingState.canceled) &#123; throw new EventBusException(\"Internal error. Abort state was not reset\"); &#125; try &#123; while (!eventQueue.isEmpty()) &#123; postSingleEvent(eventQueue.remove(0), postingState); &#125; &#125; finally &#123; postingState.isPosting = false; postingState.isMainThread = false; &#125; &#125; &#125; postToSubscription 函数中会判断订阅者的 ThreadMode，从而决定在什么 Mode 下执行事件响应函数。ThreadMode 共有四类： PostThread：默认的 ThreadMode，表示在执行 Post 操作的线程直接调用订阅者的事件响应方法，不论该线程是否为主线程（UI 线程）。当该线程为主线程时，响应方法中不能有耗时操作，否则有卡主线程的风险。适用场景：对于是否在主线程执行无要求，但若 Post 线程为主线程，不能耗时的操作； MainThread：在主线程中执行响应方法。如果发布线程就是主线程，则直接调用订阅者的事件响应方法，否则通过主线程的 Handler 发送消息在主线程中处理——调用订阅者的事件响应函数。显然，MainThread类的方法也不能有耗时操作，以避免卡主线程。适用场景：必须在主线程执行的操作； BackgroundThread：在后台线程中执行响应方法。如果发布线程不是主线程，则直接调用订阅者的事件响应函数，否则启动唯一的后台线程去处理。由于后台线程是唯一的，当事件超过一个的时候，它们会被放在队列中依次执行，因此该类响应方法虽然没有PostThread类和MainThread类方法对性能敏感，但最好不要有重度耗时的操作或太频繁的轻度耗时操作，以造成其他操作等待。适用场景：操作轻微耗时且不会过于频繁，即一般的耗时操作都可以放在这里； Async：不论发布线程是否为主线程，都使用一个空闲线程来处理。和BackgroundThread不同的是，Async类的所有线程是相互独立的，因此不会出现卡线程的问题。适用场景：长耗时操作，例如网络访问。 5.unregister通过typesBySubscriber来取出这个subscriber订阅者订阅的事件类型,从typesBySubscriber移除subscriber。1234567891011public synchronized void unregister(Object subscriber) &#123; List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber); if (subscribedTypes != null) &#123; for (Class&lt;?&gt; eventType : subscribedTypes) &#123; unsubscribeByEventType(subscriber, eventType); &#125; typesBySubscriber.remove(subscriber); &#125; else &#123; Log.w(TAG, \"Subscriber to unregister was not registered before: \" + subscriber.getClass()); &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://yoursite.com/categories/Android/"}],"tags":[]}]}