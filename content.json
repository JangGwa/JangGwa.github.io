{"meta":{"title":"jinguo's home","subtitle":null,"description":null,"author":"JinGuo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-30T07:45:49.613Z","updated":"2019-01-30T07:44:43.178Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"金果的书屋，随心所欲的写想写的东西。"}],"posts":[{"title":"书评-YDKJSthis与对象原型","slug":"书评-YDKJSthis与对象原型","date":"2019-03-12T16:00:00.000Z","updated":"2019-03-12T16:00:00.000Z","comments":true,"path":"2019/03/13/书评-YDKJSthis与对象原型/","link":"","permalink":"http://yoursite.com/2019/03/13/书评-YDKJSthis与对象原型/","excerpt":"","text":"第一章：this 是什么this 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。 this 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。 this 既不是函数自身的引用，也不是函数词法作用域的引用。 this 实际上是在函数被调用时建立的一个绑定，它指向什么是完全由函数被调用的调用点来决定的。 首先展示一下 this 的动机和用途:12345678910111213141516171819202122function identify() &#123; return this.name.toUpperCase();&#125;function speak() &#123; var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting );&#125;var me = &#123; name: \"Kyle\"&#125;;var you = &#123; name: \"Reader\"&#125;;identify.call( me ); // KYLEidentify.call( you ); // READERspeak.call( me ); // Hello, I'm KYLEspeak.call( you ); // Hello, I'm READER 与使用 this 相反地，你可以明确地将环境对象传递给 identify() 和 speak().1234567891011function identify(context) &#123; return context.name.toUpperCase();&#125;function speak(context) &#123; var greeting = \"Hello, I'm \" + identify( context ); console.log( greeting );&#125;identify( you ); // READERspeak( me ); // Hello, I'm KYLE this 机制提供了更优雅的方式来隐含地传递一个对象引用，导致更加干净的API设计和更容易的复用。 第二章：this 豁然开朗首先我们展示一下调用栈和调用点：123456789101112131415161718192021222324function baz() &#123; // 调用栈是: `baz` // 我们的调用点是 global scope（全局作用域） console.log( \"baz\" ); bar(); // &lt;-- `bar` 的调用点&#125;function bar() &#123; // 调用栈是: `baz` -&gt; `bar` // 我们的调用点位于 `baz` console.log( \"bar\" ); foo(); // &lt;-- `foo` 的 call-site&#125;function foo() &#123; // 调用栈是: `baz` -&gt; `bar` -&gt; `foo` // 我们的调用点位于 `bar` console.log( \"foo\" );&#125;baz(); // &lt;-- `baz` 的调用点 在分析代码来寻找（从调用栈中）真正的调用点时要小心，因为它是影响 this 绑定的唯一因素。 那么调用点是如何决定在函数执行期间 this 指向哪里的。 我们有四种 this 绑定规则：默认绑定、隐含绑定、明确绑定、new 绑定。 判定 this 的步骤： 我们可以先判断函数是通过 new 被调用的嘛？如果是， this 就是新构建的函数。 然后判断函数是通过 call 或 apply 被调用，甚至是隐藏在 bind 硬绑定中吗？ 如果是，this 就是那个被明确指定的对象。 然后判断函数是通过环境对象被调用的嘛？ 如果是，this 就是那个环境对象。 否则，使用默认的 this。如果在 strict mode 下，就是 undefined，否则就是 global 对象。 如果传递 null 或 undefined 作为 call、 apply 或 bind 的 this 绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。这样会带来一些潜在的危险。如果你这样处理一些函数调用，而且那些函数确实使用了 this 引用，那么默认绑定规则意味着它可能会不经意间引用 global 对象。很显然，这样的陷阱会导致多种非常难诊断和追踪的 bug。安全的做法是通过 Object.create(null) 来作为绑定参数。 我们知道硬绑定是一种通过将函数强制绑定到特定的 this 上，来防止函数调用在不经意间退回到默认绑定的策略。问题是，硬绑定极大地降低了函数的灵活性，阻止我们手动使用隐含绑定或后续的明确绑定来覆盖 this。 软化绑定的思路就是为默认绑定提供不同的默认值，同时保持函数可以通过隐含绑定或明确绑定技术来手动绑定 this。 下面我们就分别展示硬绑定和软化绑定的代码实现硬绑定12345678910111213141516171819202122232425262728if (!Function.prototype.bind) &#123; Function.prototype.bind = function(oThis) &#123; if (typeof this !== \"function\") &#123; // 可能的与 ECMAScript 5 内部的 IsCallable 函数最接近的东西， throw new TypeError( \"Function.prototype.bind - what \" + \"is trying to be bound is not callable\" ); &#125; var aArgs = Array.prototype.slice.call( arguments, 1 ), fToBind = this, fNOP = function()&#123;&#125;, fBound = function()&#123; return fToBind.apply( ( this instanceof fNOP &amp;&amp; oThis ? this : oThis ), aArgs.concat( Array.prototype.slice.call( arguments ) ) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;;&#125; 软绑定12345678910111213141516171819if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; var fn = this, curried = [].slice.call( arguments, 1 ), bound = function bound() &#123; return fn.apply( (!this || (typeof window !== \"undefined\" &amp;&amp; this === window) || (typeof global !== \"undefined\" &amp;&amp; this === global) ) ? obj : this, curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); return bound; &#125;;&#125; 第三章：对象对象是大多是 JS 程序依赖的基本构建块儿。 一个常见的错误论断是“JavaScript中的一切都是对象”。这明显是不对的。比如 string、number、boolean、null、undefined 这几个简单基本类型自身不是 object。 一个 JSON 安全的对象可以简单地这样复制：1var newObj = JSON.parse( JSON.stringify( someObj ) ); 浅拷贝可以使用 Object.assign()来实现。 所有的属性都用属性描述符来描述，通过Object.getOwnPropertyDescriptor()来查看，会发现一个对象不仅只有 value 值，还有 writable、enumerable 和 configurable。 当然我们也可以使用Object.defineProperty()来添加新属性或使用期望的性质来修改既存的属性。 writable 控制着改变属性值的能力。 configurable 控制着该对象是否可配置 enumerable 控制该对象是否可枚举 防止扩展：Object.preventExtensions()可以防止一个对象被添加新的属性，同时保留其他既存的对象属性。 封印：Object.seal()既不能添加更多的属性，也不能重新配置或删除既存属性，但是你依然可以修改他们的值。 冻结：Object.freeze()阻止任何对对象或对象直属属性的改变。 属性不必非要包含值 —— 它们也可以是带有 getter/setter 的“访问器属性”。123456789101112131415var myObject = &#123; // 为 `a` 定义 getter get a() &#123; return this._a_; &#125;, // 为 `a` 定义 setter set a(val) &#123; this._a_ = val * 2; &#125;&#125;;myObject.a = 2;myObject.a; // 4 你也可以使用 ES6 的 for..of 语法，在数据结构（数组，对象等）中迭代值，它寻找一个内建或自定义的 @@iterator 对象，这个对象由一个 next() 方法组成，通过这个 next() 方法每次迭代一个数据。123456789101112131415161718192021222324252627282930313233343536var myObject = &#123; a: 2, b: 3&#125;;Object.defineProperty( myObject, Symbol.iterator, &#123; enumerable: false, writable: false, configurable: true, value: function() &#123; var o = this; var idx = 0; var ks = Object.keys( o ); return &#123; next: function() &#123; return &#123; value: o[ks[idx++]], done: (idx &gt; ks.length) &#125;; &#125; &#125;; &#125;&#125; );// 手动迭代 `myObject`var it = myObject[Symbol.iterator]();it.next(); // &#123; value:2, done:false &#125;it.next(); // &#123; value:3, done:false &#125;it.next(); // &#123; value:undefined, done:true &#125;// 用 `for..of` 迭代 `myObject`for (var v of myObject) &#123; console.log( v );&#125;// 2// 3 第四章：混合（淆）“类”的对象类描述了一种特定的代码组织和结构形式，他有实例化、继承和多态等机制。 mixin 模式常用于在某种程度上模拟类的拷贝行为，但是这通常导致像显式假想多态那样（OtherObj.methodName.call(this, …)）难看而且脆弱的语法，这样的语法又常导致更难懂和更难维护的代码。 明确的 mixin 和类拷贝又不完全相同，因为对象（和函数！）仅仅是共享的引用被复制，不是对象/函数自身被复制。 第五章：原型每个普通的 [[prototype]] 链的最顶端，是内建的 Object.prototype。 我们现在来考察 myObject.foo = “bar” 赋值的三种场景，当 foo 不直接存在于 myObject，但存在于 myObject 的 [[Prototype]] 链的更高层时： 如果一个普通的名为 foo 的数据访问属性在 [[Prototype]] 链的高层某处被找到，而且没有被标记为只读（writable:false），那么一个名为 foo 的新属性就直接添加到 myObject 上，形成一个遮蔽属性。 如果一个 foo 在 [[Prototype]] 链的高层某处被找到，但是它被标记为只读（writable:false） ，那么设置既存属性和在 myObject 上创建遮蔽属性都是不允许的。如果代码运行在 strict mode 下，一个错误会被抛出。否则，这个设置属性值的操作会被无声地忽略。不论怎样，没有发生遮蔽。 如果一个 foo 在 [[Prototype]] 链的高层某处被找到，而且它是一个 setter，那么这个 setter 总是被调用。没有 foo 会被添加到（也就是遮蔽在）myObject 上，这个 foo setter 也不会被重定义。 我们通过 instanceof 或者 isPrototypeOf 方法来判断一个对象是否存在某个原型链中。 proto 的代码实现如下12345678910Object.defineProperty( Object.prototype, \"__proto__\", &#123; get: function() &#123; return Object.getPrototypeOf( this ); &#125;, set: function(o) &#123; // ES6 的 setPrototypeOf(..) Object.setPrototypeOf( this, o ); return o; &#125;&#125; ); Object.create() 的代码实现如下1234567if (!Object.create) &#123; Object.create = function(o) &#123; function F()&#123;&#125; F.prototype = o; return new F(); &#125;;&#125; 第六章：行为委托行为委托意味着对象彼此是对等的，在它们自己当中相互委托，而不是父类与子类的关系。JavaScript 的 [[Prototype]] 机制的设计本质，就是行为委托机制。这意味着我们可以选择挣扎着在 JS 上实现类机制，也可以欣然接受 [[Prototype]] 作为委托机制的本性。 面线对象和行为委托的思维模式比较如下：面向对象的代码形式：123456789101112131415161718192021function Foo(who) &#123; this.me = who;&#125;Foo.prototype.identify = function() &#123; return \"I am \" + this.me;&#125;;function Bar(who) &#123; Foo.call( this, who );&#125;Bar.prototype = Object.create( Foo.prototype );Bar.prototype.speak = function() &#123; alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = new Bar( \"b1\" );var b2 = new Bar( \"b2\" );b1.speak();b2.speak(); 面向行为委托的代码形式：12345678910111213141516171819202122var Foo = &#123; init: function(who) &#123; this.me = who; &#125;, identify: function() &#123; return \"I am \" + this.me; &#125;&#125;;var Bar = Object.create( Foo );Bar.speak = function() &#123; alert( \"Hello, \" + this.identify() + \".\" );&#125;;var b1 = Object.create( Bar );b1.init( \"b1\" );var b2 = Object.create( Bar );b2.init( \"b2\" );b1.speak();b2.speak();","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS作用域与闭包","slug":"书评-YDKJS作用域和闭包","date":"2019-02-17T16:00:00.000Z","updated":"2019-02-17T16:00:00.000Z","comments":true,"path":"2019/02/18/书评-YDKJS作用域和闭包/","link":"","permalink":"http://yoursite.com/2019/02/18/书评-YDKJS作用域和闭包/","excerpt":"","text":"第一章 什么是作用域？几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力。作用域就是定义如何在某些位置存储变量，以及如何在稍后找到这些变量。 编译器理论编译的三个步骤 1.分词/词法分析：将一连串的字符打断成有意义的片段，称为 token，例子：var a = 2;=&gt; var, a, =, 2, ;。 2.解析：将一个 token 的流转换成一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为抽象语法树（AST） 3.代码生成：这个处理将抽象语法树转换为可执行的代码。 JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中。对于 JavaScript 来说，在许多情况下，编译发生在代码执行前的仅仅几微秒之内。为了确保最快的性能，JS 引擎使用了 JIT等等 理解作用域引擎：负责从始至终的编译和执行我们的 JavaScript 程序。编译器：引擎的朋友之一；处理所有解析和代码生成的活儿。作用域：引擎的另一个朋友；收集并维护一张所有被声明的标识符的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。 对于 var a = 2;这个语句，编译器将会这样处理： 1.遇到var a，编译器让作用域去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器就忽略这个声明并继续前进。否则，编译器就让作用域去为这个作用域集合声明一个称为 a 的新变量。 2.然后编译器为引擎生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎就使用这个变量。如果没有，引擎会喊出一个错误。 嵌套的作用域嵌套的作用域就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。 遍历嵌套作用域的简单规则：引擎从当前执行的作用域开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。 第二章 词法作用域作用域的工作方式有两种占统治地位的模型。其中第一种是最常见的词法作用域，另一种是动态作用域。 JavaScript 所采用的作用域模型是词法作用域。 词法作用域是在词法分析时被定义的作用域。 欺骗词法作用域：eval 函数和 with 关键字的使用。 欺骗词法作用域的使用会导致更低下的性能。因为 JS 引擎的一些优化原理都归结在实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明在什么位置。如果发现一个 eval 或是 with，它实质上就不得不假定自己知道的所有标识符的位置可能是无效的。 第三章 函数与块儿作用域函数作用域函数中的作用域也就是声明的每一个函数都为自己创建了一个作用域。立即调用函数表达式可以生成一个自己的作用域。 块儿作用域ES6引入了 let 和 const，它们都会创建一个块儿作用域。let 做出的声明不会在他们所出现的块儿的作用域中提升。 第四章 提升在代码的任何部分被执行之前，所有的声明，变量和函数，都会首先被处理。以下是两个例子123a = 2;var a;console.log( a ); // 2 12console.log( a ); // undefinedvar a = 2; 函数声明会被提升，但是函数表达式不会。12345foo();function foo() &#123; console.log( a ); // undefined var a = 2;&#125; 12345foo(); // 不是 ReferenceError， 而是 TypeError! 因为变量 foo 被提升了，但是值为 undefinedvar foo = function bar() &#123; // ...&#125;; 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。12345678foo(); // 1var foo;function foo() &#123; console.log( 1 );&#125;foo = function() &#123; console.log( 2 );&#125;; 这个代码被引擎解释执行为1234567function foo() &#123; console.log( 1 );&#125;foo(); // 1foo = function() &#123; console.log( 2 );&#125;; 这里的一个注意点就是 var foo 是一个重复的声明，会被忽略。 第五章 作用域闭包闭包就是函数能够记住并访问它的词法作用域，即使当这个函数在它的词法作用域之外执行时。以下例子是一个典型的闭包案例123456789function foo() &#123; var a = 2; function bar() &#123; console.log( a ); &#125; return bar;&#125;var baz = foo();baz(); // 2 -- 哇噢，看到闭包了，伙计。 我们生活中经常使用到的闭包1234567function wait(message) &#123; setTimeout( function timer()&#123; console.log( message ); &#125;, 1000 );&#125;wait( \"Hello, closure!\" ); 还有模块就是利用了闭包的力量，我们看下面的代码12345678910111213141516171819202122function CoolModule() &#123; var something = \"cool\"; var another = [1, 2, 3]; function doSomething() &#123; console.log( something ); &#125; function doAnother() &#123; console.log( another.join( \" ! \" ) ); &#125; return &#123; doSomething: doSomething, doAnother: doAnother &#125;;&#125;var foo = CoolModule();foo.doSomething(); // coolfoo.doAnother(); // 1 ! 2 ! 3","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS入门与进阶","slug":"书评-YDKJS入门与进阶","date":"2019-02-14T16:00:00.000Z","updated":"2019-02-14T16:00:00.000Z","comments":true,"path":"2019/02/15/书评-YDKJS入门与进阶/","link":"","permalink":"http://yoursite.com/2019/02/15/书评-YDKJS入门与进阶/","excerpt":"","text":"第一章：进入编程代码代码是一组告诉计算机要执行什么任务的特殊指令。通常保存在文本文件中，也可以在浏览器的\b开发者控制台中直接键入代码。 语句一组单词，数字，和执行一种具体任务的操作符构成了一个语句。语句包含了变量、字面量、操作符。例如a = b * 2; 就是一个语句，而 a、b 是变量，2是字面量，=、* 是操作符。 表达式一个表达式是一个引用，指向变量或值，或者一组用操作符组合的变量和值。123452 -&gt; 字面量表达式b -&gt; 变量表达式b * 2 -&gt; 算数表达式a = b * 2 -&gt; 赋值表达式alert(a) -&gt; 函数表达式 执行一个程序\bJavaScript引擎实际上在即时地自上而下的编译程序然后立即运行编译好的代码。 第二章：进入 JavaScript值与类型内建类型有：string，number，boolean，null，undefined，symbol，object。通常我们可以用 typeof 来判断类型，但是 JS 中存在一个 bug，就是 typeof null 为 object，这个可以通过 Object.prototype.toString.call(null) 来进行判断。 值的比较true 和 false‘’, 0, -0, NaN, null, undefined, false 转 Boolean 为 false，其余都是true。 等价性不准确的描述：== 检查值的等价性而 === 检查值和类型两者的等价性。合理的描述： == 在允许强制转化的条件下检查值的等价性， === 是在不允许强制转换的条件下检查值的等价性。 this 标识符123456789101112131415161718192021function foo() &#123; console.log( this.bar );&#125;var bar = \"global\";var obj1 = &#123; bar: \"obj1\", foo: foo&#125;;var obj2 = &#123; bar: \"obj2\"&#125;;// --------foo(); // \"global\"obj1.foo(); // \"obj1\"foo.call( obj2 ); // \"obj2\"new foo(); // undefined foo() 最终在非 strict 模式中将 this 设置为全局对象 —— 在 strict 模式中，this 将会是 undefined 而且你会在访问 bar 属性时得到一个错误 —— 所以 this.bar 的值是 global。 obj1.foo() 将 this 设置为对象 obj1。 foo.call(obj2) 将 this 设置为对象 obj2。 new foo() 将 this 设置为一个新的空对象。原型它的最简单的方法是使用称为Object.create(..)的内建工具。1234567891011var foo = &#123; a: 42&#125;;// 创建 `bar` 并将它链接到 `foo`var bar = Object.create( foo );bar.b = \"hello world\";bar.b; // \"hello world\"bar.a; // 42 &lt;-- 委托到 `foo` 旧的与新的有两种主要的技术可以将新的JavaScript特性“带到”老版本的浏览器中：填补和转译。 填补ES6定义了一个称为Number.isNaN(..)的工具，来为检查NaN值提供一种准确无误的方法12345if (!Number.isNaN) &#123; Number.isNaN = function isNaN(x) &#123; return x !== x; &#125;;&#125; 优秀填补例子： ES5-Shim 和 ES6-Shim 转译ES6增加了一个称为“默认参数值”的新特性。123456function foo(a = 2) &#123; console.log( a );&#125;foo(); // 2foo( 42 ); // 42 转译器会将它转换为老版本语法1234function foo() &#123; var a = arguments[0] !== (void 0) ? arguments[0] : 2; console.log( a );&#125; 优秀转译器例子： Babel 和 Traceur 第三章：进入 YDKJS作用域与闭包JS 是“解释型语言”因此是不被编译的，这是错误的。JS 引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。闭包的一个重要应用是模块模式。 this 与对象原型最大的谬误之一是认为 this 关键字指代它所出现的函数，这是错误的。this 关键字是根据函数如何被执行而动态绑定的。 类型与文法理解强制转换，而不是杜绝它的存在。 异步与性能Prmise 是一个“未来值”的一种与时间无关的包装，它让你推理并组合这些未来值而不必关心它们是否已经准备好。另外，它们通过将回调沿着一个可信赖和可组装的 promise 机制传递，有效地解决了 IoC 信任问题。Generator给JS函数引入了一种新的执行模式，generator可以在yield点被暂停而稍后异步地被继续。这种“暂停-继续”的能力让generator在幕后异步地被处理，使看起来同步，顺序执行的代码成为可能。如此，我们就解决了回调的非线性，非本地跳转的困惑，并因此使我们的异步代码看起来是更容易推理的同步代码。 ES6与未来很多值得一读的激动人心的ES6特性：结构，参数默认值，symbol，简洁方式，计算属性，箭头函数，块儿作用域，promise，generator，iterator，模块，代理，weakmap等。JavaScript 的未来是光明的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"学习-TypeScript入门","slug":"学习-TypeScript入门","date":"2019-02-12T16:00:00.000Z","updated":"2019-02-12T16:00:00.000Z","comments":true,"path":"2019/02/13/学习-TypeScript入门/","link":"","permalink":"http://yoursite.com/2019/02/13/学习-TypeScript入门/","excerpt":"","text":"什么是 TypeScriptTypeScript 是 JavaScript 的超集，主要提供了类型系统和对 ES6 的支持。它编译出来是 JavaScript，可以运行在任何浏览器上。 TypeScript 的优点 增加了代码的可读性和可维护性（类型系统、编译报错、代码补全、接口提示等） TypeScript 非常包容（类型推论、定义一切类型、兼容三方库等） TypeScript 拥有活跃的社区（Angular2 是 TypeScript 编写，大部分三方库提供 TypeScript 类型定义文件）TypeScript 的缺点 有一定的学习成本（接口、泛型等） 会增加一些开发成本（多写一些类型的定义） TypeScript 安装命令行： npm install -g typescript安装完成后会在全局环境安装tsc\b命令，编译一个 typescript 文件直接用命令 tsc xxx.ts 即可。 TypeScript 使用原始数据类型原始数据类型包括：布尔型、数值型、字符串、null、undefined\b、Symbol。 布尔值let isBoolean: boolean = false; 数值let num: number = 1; 字符串let str: string = &#39;str&#39;; 空值123function alertName(): void &#123; alert('My Name is xxx');&#125; Null 和 Undefined1let u: undefined = undefined; 1let n: null = null; 任意值任意值用来表示允许赋值为任意类型。12let something: any = 'xxx';something = 1; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。 联合类型联合类型表示取值可以为多种类型中的一种。123let something: string | number;something = 'xxx';something = 1; 对象的类型–接口在 TypeScript 中，我们使用接口来定义对象的类型。12345678interface Person &#123; name: string; age: number;&#125;let ingot: Person = &#123; name: 'ingot', age: 25&#125; 定义的接口首字母大写。定义的变量比接口少一些属性和多一些属性都是不允许的。 可选属性1234567interface Person &#123; name: string; age?: number;&#125;let ingot: Person = &#123; name: 'ingot'&#125; 任意属性12345678interface Person &#123; name: string; [propName: string]: any;&#125;let ingot: Person = &#123; name: 'ingot', age: 11&#125; 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性。 只读属性1234interface Person &#123; readonly id: number, name: string&#125; 数组的类型类型+方括号表示法1let arr: number[] = [1, 2, 3, 4, 5]; 数组泛型1let arr: Array&lt;number&gt; = [1, 2, 3, 4, 5]; 用接口表示数组1234interface NumberArray &#123; [index: number]: number&#125;let arr: NumberArray = [1, 2, 3, 4, 5]; 函数的类型函数声明123function sum(x: number, y: number): number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的 函数表达式123let sum:(x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125; 类型别名我们使用 type 创建类型别名。1type Name = string;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]}]}