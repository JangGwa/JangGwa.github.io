{"meta":{"title":"jinguo's home","subtitle":null,"description":null,"author":"JinGuo","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-01-30T07:45:49.613Z","updated":"2019-01-30T07:44:43.178Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"金果的书屋，随心所欲的写想写的东西。"}],"posts":[{"title":"","slug":"plan","date":"2019-02-21T06:02:30.771Z","updated":"2019-02-21T06:03:58.136Z","comments":true,"path":"2019/02/21/plan/","link":"","permalink":"http://yoursite.com/2019/02/21/plan/","excerpt":"","text":"1.基础学习（YDKJS、es6、interviewmap）2.设计模式学习3.源码设计（react、webpack）","categories":[],"tags":[]},{"title":"书评-YDKJS作用域与闭包","slug":"书评-YDKJS作用域和闭包","date":"2019-02-17T16:00:00.000Z","updated":"2019-02-17T16:00:00.000Z","comments":true,"path":"2019/02/18/书评-YDKJS作用域和闭包/","link":"","permalink":"http://yoursite.com/2019/02/18/书评-YDKJS作用域和闭包/","excerpt":"","text":"第一章 什么是作用域？几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值的能力。作用域就是定义如何在某些位置存储变量，以及如何在稍后找到这些变量。 编译器理论编译的三个步骤 1.分词/词法分析：将一连串的字符打断成有意义的片段，称为 token，例子：var a = 2;=&gt; var, a, =, 2, ;。 2.解析：将一个 token 的流转换成一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为抽象语法树（AST） 3.代码生成：这个处理将抽象语法树转换为可执行的代码。 JavaScript 的编译和其他语言不同，不是提前发生在一个构建的步骤中。对于 JavaScript 来说，在许多情况下，编译发生在代码执行前的仅仅几微秒之内。为了确保最快的性能，JS 引擎使用了 JIT等等 理解作用域引擎：负责从始至终的编译和执行我们的 JavaScript 程序。编译器：引擎的朋友之一；处理所有解析和代码生成的活儿。作用域：引擎的另一个朋友；收集并维护一张所有被声明的标识符的列表，并对当前执行中的代码如何访问这些变量强制实施一组严格的规则。 对于 var a = 2;这个语句，编译器将会这样处理： 1.遇到var a，编译器让作用域去查看对于这个特定的作用域集合，变量 a 是否已经存在了。如果是，编译器就忽略这个声明并继续前进。否则，编译器就让作用域去为这个作用域集合声明一个称为 a 的新变量。 2.然后编译器为引擎生成稍后要执行的代码，来处理赋值 a = 2。引擎 运行的代码首先让作用域 去查看在当前的作用域集合中是否有一个称为 a 的变量可以访问。如果有，引擎就使用这个变量。如果没有，引擎会喊出一个错误。 嵌套的作用域嵌套的作用域就像一个代码块儿或函数被嵌套在另一个代码块儿或函数中一样，作用域被嵌套在其他的作用域中。 遍历嵌套作用域的简单规则：引擎从当前执行的作用域开始，在那里查找变量，如果没有找到，就向上走一级继续查找，如此类推。如果到了最外层的全局作用域，那么查找就会停止，无论它是否找到了变量。 第二章 词法作用域作用域的工作方式有两种占统治地位的模型。其中第一种是最常见的词法作用域，另一种是动态作用域。 JavaScript 所采用的作用域模型是词法作用域。 词法作用域是在词法分析时被定义的作用域。 欺骗词法作用域：eval 函数和 with 关键字的使用。 欺骗词法作用域的使用会导致更低下的性能。因为 JS 引擎的一些优化原理都归结在实质上在进行词法分析时可以静态地分析代码，并提前决定所有的变量和函数声明在什么位置。如果发现一个 eval 或是 with，它实质上就不得不假定自己知道的所有标识符的位置可能是无效的。 第三章 函数与块儿作用域函数中的作用域也就是声明的每一个函数都为自己创建了一个作用域。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"书评-YDKJS入门与进阶","slug":"书评-YDKJS入门与进阶","date":"2019-02-14T16:00:00.000Z","updated":"2019-02-14T16:00:00.000Z","comments":true,"path":"2019/02/15/书评-YDKJS入门与进阶/","link":"","permalink":"http://yoursite.com/2019/02/15/书评-YDKJS入门与进阶/","excerpt":"","text":"第一章：进入编程代码代码是一组告诉计算机要执行什么任务的特殊指令。通常保存在文本文件中，也可以在浏览器的\b开发者控制台中直接键入代码。 语句一组单词，数字，和执行一种具体任务的操作符构成了一个语句。语句包含了变量、字面量、操作符。例如a = b * 2; 就是一个语句，而 a、b 是变量，2是字面量，=、* 是操作符。 表达式一个表达式是一个引用，指向变量或值，或者一组用操作符组合的变量和值。123452 -&gt; 字面量表达式b -&gt; 变量表达式b * 2 -&gt; 算数表达式a = b * 2 -&gt; 赋值表达式alert(a) -&gt; 函数表达式 执行一个程序\bJavaScript引擎实际上在即时地自上而下的编译程序然后立即运行编译好的代码。 第二章：进入 JavaScript值与类型内建类型有：string，number，boolean，null，undefined，symbol，object。通常我们可以用 typeof 来判断类型，但是 JS 中存在一个 bug，就是 typeof null 为 object，这个可以通过 Object.prototype.toString.call(null) 来进行判断。 值的比较true 和 false‘’, 0, -0, NaN, null, undefined, false 转 Boolean 为 false，其余都是true。 等价性不准确的描述：== 检查值的等价性而 === 检查值和类型两者的等价性。合理的描述： == 在允许强制转化的条件下检查值的等价性， === 是在不允许强制转换的条件下检查值的等价性。 this 标识符123456789101112131415161718192021function foo() &#123; console.log( this.bar );&#125;var bar = \"global\";var obj1 = &#123; bar: \"obj1\", foo: foo&#125;;var obj2 = &#123; bar: \"obj2\"&#125;;// --------foo(); // \"global\"obj1.foo(); // \"obj1\"foo.call( obj2 ); // \"obj2\"new foo(); // undefined foo() 最终在非 strict 模式中将 this 设置为全局对象 —— 在 strict 模式中，this 将会是 undefined 而且你会在访问 bar 属性时得到一个错误 —— 所以 this.bar 的值是 global。 obj1.foo() 将 this 设置为对象 obj1。 foo.call(obj2) 将 this 设置为对象 obj2。 new foo() 将 this 设置为一个新的空对象。原型它的最简单的方法是使用称为Object.create(..)的内建工具。1234567891011var foo = &#123; a: 42&#125;;// 创建 `bar` 并将它链接到 `foo`var bar = Object.create( foo );bar.b = \"hello world\";bar.b; // \"hello world\"bar.a; // 42 &lt;-- 委托到 `foo` 旧的与新的有两种主要的技术可以将新的JavaScript特性“带到”老版本的浏览器中：填补和转译。 填补ES6定义了一个称为Number.isNaN(..)的工具，来为检查NaN值提供一种准确无误的方法12345if (!Number.isNaN) &#123; Number.isNaN = function isNaN(x) &#123; return x !== x; &#125;;&#125; 优秀填补例子： ES5-Shim 和 ES6-Shim 转译ES6增加了一个称为“默认参数值”的新特性。123456function foo(a = 2) &#123; console.log( a );&#125;foo(); // 2foo( 42 ); // 42 转译器会将它转换为老版本语法1234function foo() &#123; var a = arguments[0] !== (void 0) ? arguments[0] : 2; console.log( a );&#125; 优秀转译器例子： Babel 和 Traceur 第三章：进入 YDKJS作用域与闭包JS 是“解释型语言”因此是不被编译的，这是错误的。JS 引擎在你的代码执行的前一刻（有时是在执行期间！）编译它。闭包的一个重要应用是模块模式。 this 与对象原型最大的谬误之一是认为 this 关键字指代它所出现的函数，这是错误的。this 关键字是根据函数如何被执行而动态绑定的。 类型与文法理解强制转换，而不是杜绝它的存在。 异步与性能Prmise 是一个“未来值”的一种与时间无关的包装，它让你推理并组合这些未来值而不必关心它们是否已经准备好。另外，它们通过将回调沿着一个可信赖和可组装的 promise 机制传递，有效地解决了 IoC 信任问题。Generator给JS函数引入了一种新的执行模式，generator可以在yield点被暂停而稍后异步地被继续。这种“暂停-继续”的能力让generator在幕后异步地被处理，使看起来同步，顺序执行的代码成为可能。如此，我们就解决了回调的非线性，非本地跳转的困惑，并因此使我们的异步代码看起来是更容易推理的同步代码。 ES6与未来很多值得一读的激动人心的ES6特性：结构，参数默认值，symbol，简洁方式，计算属性，箭头函数，块儿作用域，promise，generator，iterator，模块，代理，weakmap等。JavaScript 的未来是光明的。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]},{"title":"学习-TypeScript入门","slug":"学习-TypeScript入门","date":"2019-02-12T16:00:00.000Z","updated":"2019-02-12T16:00:00.000Z","comments":true,"path":"2019/02/13/学习-TypeScript入门/","link":"","permalink":"http://yoursite.com/2019/02/13/学习-TypeScript入门/","excerpt":"","text":"什么是 TypeScriptTypeScript 是 JavaScript 的超集，主要提供了类型系统和对 ES6 的支持。它编译出来是 JavaScript，可以运行在任何浏览器上。 TypeScript 的优点 增加了代码的可读性和可维护性（类型系统、编译报错、代码补全、接口提示等） TypeScript 非常包容（类型推论、定义一切类型、兼容三方库等） TypeScript 拥有活跃的社区（Angular2 是 TypeScript 编写，大部分三方库提供 TypeScript 类型定义文件）TypeScript 的缺点 有一定的学习成本（接口、泛型等） 会增加一些开发成本（多写一些类型的定义） TypeScript 安装命令行： npm install -g typescript安装完成后会在全局环境安装tsc\b命令，编译一个 typescript 文件直接用命令 tsc xxx.ts 即可。 TypeScript 使用原始数据类型原始数据类型包括：布尔型、数值型、字符串、null、undefined\b、Symbol。 布尔值let isBoolean: boolean = false; 数值let num: number = 1; 字符串let str: string = &#39;str&#39;; 空值123function alertName(): void &#123; alert('My Name is xxx');&#125; Null 和 Undefined1let u: undefined = undefined; 1let n: null = null; 任意值任意值用来表示允许赋值为任意类型。12let something: any = 'xxx';something = 1; 类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论的规则推断出一个类型。 联合类型联合类型表示取值可以为多种类型中的一种。123let something: string | number;something = 'xxx';something = 1; 对象的类型–接口在 TypeScript 中，我们使用接口来定义对象的类型。12345678interface Person &#123; name: string; age: number;&#125;let ingot: Person = &#123; name: 'ingot', age: 25&#125; 定义的接口首字母大写。定义的变量比接口少一些属性和多一些属性都是不允许的。 可选属性1234567interface Person &#123; name: string; age?: number;&#125;let ingot: Person = &#123; name: 'ingot'&#125; 任意属性12345678interface Person &#123; name: string; [propName: string]: any;&#125;let ingot: Person = &#123; name: 'ingot', age: 11&#125; 需要注意的是，一旦定义了任意属性，那么确定属性和可选属性都必须是它的子属性。 只读属性1234interface Person &#123; readonly id: number, name: string&#125; 数组的类型类型+方括号表示法1let arr: number[] = [1, 2, 3, 4, 5]; 数组泛型1let arr: Array&lt;number&gt; = [1, 2, 3, 4, 5]; 用接口表示数组1234interface NumberArray &#123; [index: number]: number&#125;let arr: NumberArray = [1, 2, 3, 4, 5]; 函数的类型函数声明123function sum(x: number, y: number): number &#123; return x + y;&#125; 注意，输入多余的（或者少于要求的）参数，是不被允许的 函数表达式123let sum:(x: number, y: number) =&gt; number = function (x: number, y: number): number &#123; return x + y;&#125; 类型别名我们使用 type 创建类型别名。1type Name = string;","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[]}]}